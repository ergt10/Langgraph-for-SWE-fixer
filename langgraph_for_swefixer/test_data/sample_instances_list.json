[
  {
    "messages": [
      {
        "role": "user",
        "content": {
          "input": {
            "issue": "Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n",
            "readme file": {
              "README.rst": "=======\nAstropy\n=======\n\n|Actions Status| |CircleCI Status| |Azure Status| |Coverage Status| |PyPI Status| |Documentation Status| |Zenodo|\n\nThe Astropy Project (http://astropy.org/) is a community effort to develop a\nsingle core package for Astronomy in Python and foster interoperability between\nPython astronomy packages. This repository contains the core package which is\nintended to contain much of the core functionality and some common tools needed\nfor performing astronomy and astrophysics with Python.\n\nReleases are `registered on PyPI <https://pypi.org/project/astropy>`_,\nand development is occurring at the\n`project's GitHub page <http://github.com/astropy/astropy>`_.\n\nFor installation instructions, see the `online documentation <https://docs.astropy.org/>`_\nor  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n\nContributing Code, Documentation, or Feedback\n---------------------------------------------\n\nThe Astropy Project is made both by and for its users, so we welcome and\nencourage contributions of many kinds. Our goal is to keep this a positive,\ninclusive, successful, and growing community by abiding with the\n`Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n\nMore detailed information on contributing to the project or submitting feedback\ncan be found on the `contributions <http://www.astropy.org/contribute.html>`_\npage. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\nused as a quick reference when you are ready to start writing or validating\ncode for submission.\n\nSupporting the Project\n----------------------\n\n|NumFOCUS| |Donate|\n\nThe Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\nUnited States. You can donate to the project by using the link above, and this\ndonation will support our mission to promote sustainable, high-level code base\nfor the astronomy community, open code development, educational materials, and\nreproducible scientific research.\n\nLicense\n-------\n\nAstropy is licensed under a 3-clause BSD style license - see the\n`LICENSE.rst <LICENSE.rst>`_ file.\n\n.. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n    :target: https://github.com/astropy/astropy/actions\n    :alt: Astropy's GitHub Actions CI Status\n\n.. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n    :target: https://circleci.com/gh/astropy/astropy\n    :alt: Astropy's CircleCI Status\n\n.. |Azure Status| image:: https://dev.azure.com/astropy-project/astropy/_apis/build/status/astropy.astropy?repoName=astropy%2Fastropy&branchName=main\n    :target: https://dev.azure.com/astropy-project/astropy\n    :alt: Astropy's Azure Pipelines Status\n\n.. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n    :target: https://codecov.io/gh/astropy/astropy\n    :alt: Astropy's Coverage Status\n\n.. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n    :target: https://pypi.org/project/astropy\n    :alt: Astropy's PyPI Status\n\n.. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n   :target: https://doi.org/10.5281/zenodo.4670728\n   :alt: Zenodo DOI\n\n.. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n    :target: https://docs.astropy.org/en/stable/?badge=stable\n    :alt: Documentation Status\n\n.. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n    :target: http://numfocus.org\n    :alt: Powered by NumFOCUS\n\n.. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n    :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n\n\nIf you locally cloned this repo before 7 Apr 2021\n-------------------------------------------------\n\nThe primary branch for this repo has been transitioned from ``master`` to\n``main``.  If you have a local clone of this repository and want to keep your\nlocal branch in sync with this repo, you'll need to do the following in your\nlocal clone from your terminal::\n\n   git fetch --all --prune\n   # you can stop here if you don't use your local \"master\"/\"main\" branch\n   git branch -m master main\n   git branch -u origin/main main\n\nIf you are using a GUI to manage your repos you'll have to find the equivalent\ncommands as it's different for different programs. Alternatively, you can just\ndelete your local clone and re-clone!\n"
            },
            "retrieved files documentation": [
              {
                "file_path": "astropy/modeling/separable.py",
                "module_docstring": "Functions to determine if a model is separable, i.e.\nif the model outputs are independent.\n\nIt analyzes ``n_inputs``, ``n_outputs`` and the operators\nin a compound model by stepping through the transforms\nand creating a ``coord_matrix`` of shape (``n_outputs``, ``n_inputs``).\n\n\nEach modeling operator is represented by a function which\ntakes two simple models (or two ``coord_matrix`` arrays) and\nreturns an array of shape (``n_outputs``, ``n_inputs``).",
                "classes": [],
                "functions": [
                  {
                    "name": "is_separable(transform)",
                    "content": "def is_separable(transform):\n    \"\"\"\n    A separability test for the outputs of a transform.\n\n    Parameters\n...\n        return is_separable\n    separable_matrix = _separable(transform)\n    is_separable = separable_matrix.sum(1)\n    is_separable = np.where(is_separable != 1, False, True)\n    return is_separable"
                  },
                  {
                    "name": "separability_matrix(transform)",
                    "content": "def separability_matrix(transform):\n    \"\"\"\n    Compute the correlation between outputs and inputs.\n\n    Parameters\n...\n        return np.ones((transform.n_outputs, transform.n_inputs),\n                       dtype=np.bool_)\n    separable_matrix = _separable(transform)\n    separable_matrix = np.where(separable_matrix != 0, True, False)\n    return separable_matrix"
                  },
                  {
                    "name": "_compute_n_outputs(left, right)",
                    "content": "def _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n...\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp"
                  },
                  {
                    "name": "_arith_oper(left, right)",
                    "content": "def _arith_oper(left, right):\n    \"\"\"\n    Function corresponding to one of the arithmetic operators\n    ['+', '-'. '*', '/', '**'].\n\n...\n            \"n_outputs for this operator.\".format(\n                left_inputs, left_outputs, right_inputs, right_outputs))\n\n    result = np.ones((left_outputs, left_inputs))\n    return result"
                  },
                  {
                    "name": "_coord_matrix(model, pos, noutp)",
                    "content": "def _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n...\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat"
                  },
                  {
                    "name": "_cstack(left, right)",
                    "content": "def _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n...\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = 1\n\n    return np.hstack([cleft, cright])"
                  },
                  {
                    "name": "_cdot(left, right)",
                    "content": "def _cdot(left, right):\n    \"\"\"\n    Function corresponding to \"|\" operation.\n\n    Parameters\n...\n        raise ModelDefinitionError(\n            'Models cannot be combined with the \"|\" operator; '\n            'left coord_matrix is {}, right coord_matrix is {}'.format(\n                cright, cleft))\n    return result"
                  },
                  {
                    "name": "_separable(transform)",
                    "content": "def _separable(transform):\n    \"\"\"\n    Calculate the separability of outputs.\n\n    Parameters\n...\n        sepleft = _separable(transform.left)\n        sepright = _separable(transform.right)\n        return _operators[transform.op](sepleft, sepright)\n    elif isinstance(transform, Model):\n        return _coord_matrix(transform, 'left', transform.n_outputs)"
                  }
                ]
              },
              {
                "file_path": "astropy/modeling/core.py",
                "module_docstring": "This module defines base classes for all models.  The base class of all\nmodels is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\nthe base class for all fittable models. Fittable models can be linear or\nnonlinear in a regression analysis sense.\n\nAll models provide a `__call__` method which performs the transformation in\na purely mathematical way, i.e. the models are unitless.  Model instances can\nrepresent either a single model, or a \"model set\" representing multiple copies\nof the same type of model, but with potentially different values of the\nparameters in each model making up the set.",
                "classes": [
                  {
                    "name": "ModelDefinitionError(TypeError)",
                    "docstring": "Used for incorrect models definitions.",
                    "methods": []
                  },
                  {
                    "name": "_ModelMeta(abc.ABCMeta)",
                    "docstring": "Metaclass for Model.\n\nCurrently just handles auto-generating the param_names list based on\nParameter descriptors declared at the class-level of Model subclasses.",
                    "methods": [
                      "__new__(mcls, name, bases, members)",
                      "__init__(cls, name, bases, members)",
                      "__repr__(cls)",
                      "_repr_pretty_(cls, p, cycle)",
                      "__reduce__(cls)",
                      "name(cls)",
                      "_is_concrete(cls)",
                      "rename(cls, name, inputs, outputs)",
                      "_create_inverse_property(cls, members)",
                      "_create_bounding_box_property(cls, members)",
                      "_create_bounding_box_subclass(cls, func, sig)",
                      "_handle_special_methods(cls, members, pdict)",
                      "_format_cls_repr(cls, keywords)"
                    ]
                  },
                  {
                    "name": "Model()",
                    "docstring": "Base class for all models.\n\nThis is an abstract class and should not be instantiated directly.\n\nThe following initialization arguments apply to the majority of Model\nsubclasses by default (exceptions include specialized utility models\nlike `~astropy.modeling.mappings.Mapping`).  Parametric models take all\ntheir parameters as arguments, followed by any of the following optional\nkeyword arguments:\n\nParameters\n----------\nname : str, optional\n    A human-friendly name associated with this model instance\n    (particularly useful for identifying the individual components of a\n    compound model).\n\nmeta : dict, optional\n    An optional dict of user-defined metadata to attach to this model.\n    How this is used and interpreted is up to the user or individual use\n    case.\n\nn_models : int, optional\n    If given an integer greater than 1, a *model set* is instantiated\n    instead of a single model.  This affects how the parameter arguments\n    are interpreted.  In this case each parameter must be given as a list\n    or array--elements of this array are taken along the first axis (or\n    ``model_set_axis`` if specified), such that the Nth element is the\n    value of that parameter for the Nth model in the set.\n\n    See the section on model sets in the documentation for more details.\n\nmodel_set_axis : int, optional\n    This argument only applies when creating a model set (i.e. ``n_models >\n    1``).  It changes how parameter values are interpreted.  Normally the\n    first axis of each input parameter array (properly the 0th axis) is\n    taken as the axis corresponding to the model sets.  However, any axis\n    of an input array may be taken as this \"model set axis\".  This accepts\n    negative integers as well--for example use ``model_set_axis=-1`` if the\n    last (most rapidly changing) axis should be associated with the model\n    sets. Also, ``model_set_axis=False`` can be used to tell that a given\n    input should be used to evaluate all the models in the model set.\n\nfixed : dict, optional\n    Dictionary ``{parameter_name: bool}`` setting the fixed constraint\n    for one or more parameters.  `True` means the parameter is held fixed\n    during fitting and is prevented from updates once an instance of the\n    model has been created.\n\n    Alternatively the `~astropy.modeling.Parameter.fixed` property of a\n    parameter may be used to lock or unlock individual parameters.\n\ntied : dict, optional\n    Dictionary ``{parameter_name: callable}`` of parameters which are\n    linked to some other parameter. The dictionary values are callables\n    providing the linking relationship.\n\n    Alternatively the `~astropy.modeling.Parameter.tied` property of a\n    parameter may be used to set the ``tied`` constraint on individual\n    parameters.\n\nbounds : dict, optional\n    A dictionary ``{parameter_name: value}`` of lower and upper bounds of\n    parameters. Keys are parameter names. Values are a list or a tuple\n    of length 2 giving the desired range for the parameter.\n\n    Alternatively the `~astropy.modeling.Parameter.min` and\n    `~astropy.modeling.Parameter.max` or\n    ~astropy.modeling.Parameter.bounds` properties of a parameter may be\n    used to set bounds on individual parameters.\n\neqcons : list, optional\n    List of functions of length n such that ``eqcons[j](x0, *args) == 0.0``\n    in a successfully optimized problem.\n\nineqcons : list, optional\n    List of functions of length n such that ``ieqcons[j](x0, *args) >=\n    0.0`` is a successfully optimized problem.\n\nExamples\n--------\n>>> from astropy.modeling import models\n>>> def tie_center(model):\n...         mean = 50 * model.stddev\n...         return mean\n>>> tied_parameters = {'mean': tie_center}\n\nSpecify that ``'mean'`` is a tied parameter in one of two ways:\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\n...                        tied=tied_parameters)\n\nor\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\n>>> g1.mean.tied\nFalse\n>>> g1.mean.tied = tie_center\n>>> g1.mean.tied\n<function tie_center at 0x...>\n\nFixed parameters:\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\n...                        fixed={'stddev': True})\n>>> g1.stddev.fixed\nTrue\n\nor\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\n>>> g1.stddev.fixed\nFalse\n>>> g1.stddev.fixed = True\n>>> g1.stddev.fixed\nTrue",
                    "methods": [
                      "__init_subclass__(cls)",
                      "__init__(self)",
                      "_default_inputs_outputs(self)",
                      "_initialize_setters(self, kwargs)",
                      "inputs(self)",
                      "inputs(self, val)",
                      "outputs(self)",
                      "outputs(self, val)",
                      "n_inputs(self)",
                      "n_outputs(self)",
                      "_calculate_separability_matrix(self)",
                      "_initialize_unit_support(self)",
                      "input_units_strict(self)",
                      "input_units_allow_dimensionless(self)",
                      "uses_quantity(self)",
                      "__repr__(self)",
                      "__str__(self)",
                      "__len__(self)",
                      "_strip_ones(intup)",
                      "__setattr__(self, attr, value)",
                      "_pre_evaluate(self)",
                      "get_bounding_box(self, with_bbox)",
                      "_argnames(self)",
                      "_validate_input_shape(self, _input, idx, argnames, model_set_axis, check_model_set_axis)",
                      "_validate_input_shapes(self, inputs, argnames, model_set_axis)",
                      "input_shape(self, inputs)",
                      "_generic_evaluate(self, evaluate, _inputs, fill_value, with_bbox)",
                      "_post_evaluate(self, inputs, outputs, broadcasted_shapes, with_bbox)",
                      "bbox_with_units(self)",
                      "__call__(self)",
                      "_get_renamed_inputs_as_positional(self)",
                      "name(self)",
                      "name(self, val)",
                      "model_set_axis(self)",
                      "param_sets(self)",
                      "parameters(self)",
                      "parameters(self, value)",
                      "sync_constraints(self)",
                      "sync_constraints(self, value)",
                      "fixed(self)",
                      "bounds(self)",
                      "tied(self)",
                      "eqcons(self)",
                      "ineqcons(self)",
                      "has_inverse(self)",
                      "inverse(self)",
                      "inverse(self, value)",
                      "inverse(self)",
                      "has_user_inverse(self)",
                      "bounding_box(self)",
                      "bounding_box(self, bounding_box)",
                      "set_slice_args(self)",
                      "bounding_box(self)",
                      "has_user_bounding_box(self)",
                      "cov_matrix(self)",
                      "cov_matrix(self, cov)",
                      "stds(self)",
                      "stds(self, stds)",
                      "separable(self)",
                      "without_units_for_data(self)",
                      "output_units(self)",
                      "strip_units_from_tree(self)",
                      "with_units_from_data(self)",
                      "_has_units(self)",
                      "_supports_unit_fitting(self)",
                      "evaluate(self)",
                      "sum_of_implicit_terms(self)",
                      "render(self, out, coords)",
                      "input_units(self)",
                      "return_units(self)",
                      "_prepare_inputs_single_model(self, params, inputs)",
                      "_remove_axes_from_shape(shape, axis)",
                      "_prepare_inputs_model_set(self, params, inputs, model_set_axis_input)",
                      "prepare_inputs(self)",
                      "_validate_input_units(self, inputs, equivalencies, inputs_map)",
                      "_process_output_units(self, inputs, outputs)",
                      "_prepare_output_single_model(output, broadcast_shape)",
                      "_prepare_outputs_single_model(self, outputs, broadcasted_shapes)",
                      "_prepare_outputs_model_set(self, outputs, broadcasted_shapes, model_set_axis)",
                      "prepare_outputs(self, broadcasted_shapes)",
                      "copy(self)",
                      "deepcopy(self)",
                      "rename(self, name)",
                      "coerce_units(self, input_units, return_units, input_units_equivalencies, input_units_allow_dimensionless)",
                      "n_submodels(self)",
                      "_initialize_constraints(self, kwargs)",
                      "_initialize_parameters(self, args, kwargs)",
                      "_initialize_parameter_value(self, param_name, value)",
                      "_initialize_slices(self)",
                      "_parameters_to_array(self)",
                      "_array_to_parameters(self)",
                      "_check_param_broadcast(self, max_ndim)",
                      "_param_sets(self, raw, units)",
                      "_format_repr(self, args, kwargs, defaults)",
                      "_format_str(self, keywords, defaults)"
                    ]
                  },
                  {
                    "name": "FittableModel(Model)",
                    "docstring": "Base class for models that can be fitted using the built-in fitting\nalgorithms.",
                    "methods": []
                  },
                  {
                    "name": "Fittable1DModel(FittableModel)",
                    "docstring": "Base class for one-dimensional fittable models.\n\nThis class provides an easier interface to defining new models.\nExamples can be found in `astropy.modeling.functional_models`.",
                    "methods": []
                  },
                  {
                    "name": "Fittable2DModel(FittableModel)",
                    "docstring": "Base class for two-dimensional fittable models.\n\nThis class provides an easier interface to defining new models.\nExamples can be found in `astropy.modeling.functional_models`.",
                    "methods": []
                  },
                  {
                    "name": "CompoundModel(Model)",
                    "docstring": "Base class for compound models.\n\nWhile it can be used directly, the recommended way\nto combine models is through the model operators.",
                    "methods": [
                      "__init__(self, op, left, right, name)",
                      "_get_left_inputs_from_args(self, args)",
                      "_get_right_inputs_from_args(self, args)",
                      "_get_left_params_from_args(self, args)",
                      "_get_right_params_from_args(self, args)",
                      "_get_kwarg_model_parameters_as_positional(self, args, kwargs)",
                      "_apply_operators_to_value_lists(self, leftval, rightval)",
                      "evaluate(self)",
                      "n_submodels(self)",
                      "submodel_names(self)",
                      "both_inverses_exist(self)",
                      "_pre_evaluate(self)",
                      "_argnames(self)",
                      "_post_evaluate(self, inputs, outputs, broadcasted_shapes, with_bbox)",
                      "_evaluate(self)",
                      "param_names(self)",
                      "_make_leaflist(self)",
                      "__getattr__(self, name)",
                      "__getitem__(self, index)",
                      "_str_index_to_int(self, str_index)",
                      "n_inputs(self)",
                      "n_inputs(self, value)",
                      "n_outputs(self)",
                      "n_outputs(self, value)",
                      "eqcons(self)",
                      "eqcons(self, value)",
                      "ineqcons(self)",
                      "ineqcons(self, value)",
                      "traverse_postorder(self, include_operator)",
                      "_format_expression(self, format_leaf)",
                      "_format_components(self)",
                      "__str__(self)",
                      "rename(self, name)",
                      "isleaf(self)",
                      "inverse(self)",
                      "fittable(self)",
                      "_map_parameters(self)",
                      "_initialize_slices(self)",
                      "_recursive_lookup(branch, adict, key)",
                      "inputs_map(self)",
                      "_parameter_units_for_data_units(self, input_units, output_units)",
                      "input_units(self)",
                      "input_units_equivalencies(self)",
                      "input_units_allow_dimensionless(self)",
                      "input_units_strict(self)",
                      "return_units(self)",
                      "outputs_map(self)",
                      "has_user_bounding_box(self)",
                      "render(self, out, coords)",
                      "replace_submodel(self, name, model)",
                      "_set_sub_models_and_parameter_units(self, left, right)",
                      "without_units_for_data(self)",
                      "with_units_from_data(self)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "_model_oper(oper)",
                    "content": "def _model_oper(oper, **kwargs):\n    \"\"\"\n    Returns a function that evaluates a given Python arithmetic operator\n    between two models.  The operator should be given as a string, like ``'+'``\n    or ``'**'``.\n    \"\"\"\n    return lambda left, right: CompoundModel(oper, left, right, **kwargs)"
                  },
                  {
                    "name": "_make_arithmetic_operator(oper)",
                    "content": "def _make_arithmetic_operator(oper):\n    # We don't bother with tuple unpacking here for efficiency's sake, but for\n    # documentation purposes:\n    #\n    #     f_eval, f_n_inputs, f_n_outputs = f\n...\n    # and similarly for g\n    def op(f, g):\n        return (make_binary_operator_eval(oper, f[0], g[0]), f[1], f[2])\n\n    return op"
                  },
                  {
                    "name": "_composition_operator(f, g)",
                    "content": "def _composition_operator(f, g):\n    # We don't bother with tuple unpacking here for efficiency's sake, but for\n    # documentation purposes:\n    #\n    #     f_eval, f_n_inputs, f_n_outputs = f\n    #\n    # and similarly for g\n    return (lambda inputs, params: g[0](f[0](inputs, params), params),\n            f[1], g[2])"
                  },
                  {
                    "name": "_join_operator(f, g)",
                    "content": "def _join_operator(f, g):\n    # We don't bother with tuple unpacking here for efficiency's sake, but for\n    # documentation purposes:\n    #\n    #     f_eval, f_n_inputs, f_n_outputs = f\n...\n    #\n    # and similarly for g\n    return (lambda inputs, params: (f[0](inputs[:f[1]], params) +\n                                    g[0](inputs[f[1]:], params)),\n            f[1] + g[1], f[2] + g[2])"
                  },
                  {
                    "name": "_add_special_operator(sop_name, sop)",
                    "content": "def _add_special_operator(sop_name, sop):\n    return SPECIAL_OPERATORS.add(sop_name, sop)"
                  },
                  {
                    "name": "_get_submodel_path(model, name)",
                    "content": "def _get_submodel_path(model, name):\n    \"\"\"Find the route down a CompoundModel's tree to the model with the\n    specified name (whether it's a leaf or not)\"\"\"\n    if getattr(model, 'name', None) == name:\n        return []\n...\n        pass\n    try:\n        return ['right'] + _get_submodel_path(model.right, name)\n    except (AttributeError, TypeError):\n        pass"
                  },
                  {
                    "name": "binary_operation(binoperator, left, right)",
                    "content": "def binary_operation(binoperator, left, right):\n    '''\n    Perform binary operation. Operands may be matching tuples of operands.\n    '''\n    if isinstance(left, tuple) and isinstance(right, tuple):\n        return tuple([binoperator(item[0], item[1])\n                      for item in zip(left, right)])\n    return binoperator(left, right)"
                  },
                  {
                    "name": "get_ops(tree, opset)",
                    "content": "def get_ops(tree, opset):\n    \"\"\"\n    Recursive function to collect operators used.\n    \"\"\"\n    if isinstance(tree, CompoundModel):\n...\n        opset.add(tree.op)\n        get_ops(tree.left, opset)\n        get_ops(tree.right, opset)\n    else:\n        return"
                  },
                  {
                    "name": "make_subtree_dict(tree, nodepath, tdict, leaflist)",
                    "content": "def make_subtree_dict(tree, nodepath, tdict, leaflist):\n    '''\n    Traverse a tree noting each node by a key that indicates all the\n    left/right choices necessary to reach that node. Each key will\n    reference a tuple that contains:\n...\n        leftmostind = len(leaflist)\n        make_subtree_dict(tree.left, nodepath+'l', tdict, leaflist)\n        make_subtree_dict(tree.right, nodepath+'r', tdict, leaflist)\n        rightmostind = len(leaflist)-1\n        tdict[nodepath] = (tree, leftmostind, rightmostind)"
                  },
                  {
                    "name": "fix_inputs(modelinstance, values, bounding_boxes, selector_args)",
                    "content": "def fix_inputs(modelinstance, values, bounding_boxes=None, selector_args=None):\n    \"\"\"\n    This function creates a compound model with one or more of the input\n    values of the input model assigned fixed values (scalar or array).\n\n...\n        new_bbox = bbox[_selector]\n        new_bbox = new_bbox.__class__.validate(model, new_bbox)\n\n        model.bounding_box = new_bbox\n    return model"
                  },
                  {
                    "name": "bind_bounding_box(modelinstance, bounding_box, ignored, order)",
                    "content": "def bind_bounding_box(modelinstance, bounding_box, ignored=None, order='C'):\n    \"\"\"\n    Set a validated bounding box to a model instance.\n\n    Parameters\n...\n    \"\"\"\n    modelinstance.bounding_box = ModelBoundingBox.validate(modelinstance,\n                                                           bounding_box,\n                                                           ignored=ignored,\n                                                           order=order)"
                  },
                  {
                    "name": "bind_compound_bounding_box(modelinstance, bounding_boxes, selector_args, create_selector, ignored, order)",
                    "content": "def bind_compound_bounding_box(modelinstance, bounding_boxes, selector_args,\n                               create_selector=None, ignored=None, order='C'):\n    \"\"\"\n    Add a validated compound bounding box to a model instance.\n\n...\n    modelinstance.bounding_box = CompoundBoundingBox.validate(modelinstance,\n                                                              bounding_boxes, selector_args,\n                                                              create_selector=create_selector,\n                                                              ignored=ignored,\n                                                              order=order)"
                  },
                  {
                    "name": "custom_model()",
                    "content": "def custom_model(*args, fit_deriv=None):\n    \"\"\"\n    Create a model from a user defined function. The inputs and parameters of\n    the model will be inferred from the arguments of the function.\n\n...\n        raise TypeError(\n            \"{0} takes at most one positional argument (the callable/\"\n            \"function to be turned into a model.  When used as a decorator \"\n            \"it should be passed keyword arguments only (if \"\n            \"any).\".format(__name__))"
                  },
                  {
                    "name": "_custom_model_inputs(func)",
                    "content": "def _custom_model_inputs(func):\n    \"\"\"\n    Processes the inputs to the `custom_model`'s function into the appropriate\n    categories.\n\n...\n            raise ValueError(f\"Parameter '{param.name}' cannot be a model property: {properties}.\")\n        else:\n            params[param.name] = param.default\n\n    return inputs, special_params, settable_params, params"
                  },
                  {
                    "name": "_custom_model_wrapper(func, fit_deriv)",
                    "content": "def _custom_model_wrapper(func, fit_deriv=None):\n    \"\"\"\n    Internal implementation `custom_model`.\n\n    When `custom_model` is called as a function its arguments are passed to\n...\n    members.update(params)\n\n    cls = type(model_name, (FittableModel,), members)\n    cls._separable = True if (len(inputs) == 1) else False\n    return cls"
                  },
                  {
                    "name": "render_model(model, arr, coords)",
                    "content": "def render_model(model, arr=None, coords=None):\n    \"\"\"\n    Evaluates a model on an input array. Evaluation is limited to\n    a bounding box if the `Model.bounding_box` attribute is set.\n\n...\n            coords = np.mgrid[limits]\n\n        arr += model(*coords[::-1])\n\n    return arr"
                  },
                  {
                    "name": "hide_inverse(model)",
                    "content": "def hide_inverse(model):\n    \"\"\"\n    This is a convenience function intended to disable automatic generation\n    of the inverse in compound models by disabling one of the constituent\n    model's inverse. This is to handle cases where user provided inverse\n...\n    Note that this permanently disables it. To prevent that either copy\n    the model or restore the inverse later.\n    \"\"\"\n    del model.inverse\n    return model"
                  }
                ]
              },
              {
                "file_path": "astropy/modeling/fitting.py",
                "module_docstring": "This module implements classes (called Fitters) which combine optimization\nalgorithms (typically from `scipy.optimize`) with statistic functions to perform\nfitting. Fitters are implemented as callable classes. In addition to the data\nto fit, the ``__call__`` method takes an instance of\n`~astropy.modeling.core.FittableModel` as input, and returns a copy of the\nmodel with its parameters determined by the optimizer.\n\nOptimization algorithms, called \"optimizers\" are implemented in\n`~astropy.modeling.optimizers` and statistic functions are in\n`~astropy.modeling.statistic`. The goal is to provide an easy to extend\nframework and allow users to easily create new fitters by combining statistics\nwith optimizers.\n\nThere are two exceptions to the above scheme.\n`~astropy.modeling.fitting.LinearLSQFitter` uses Numpy's `~numpy.linalg.lstsq`\nfunction.  `~astropy.modeling.fitting.LevMarLSQFitter` uses\n`~scipy.optimize.leastsq` which combines optimization and statistic in one\nimplementation.",
                "classes": [
                  {
                    "name": "Covariance()",
                    "docstring": "Class for covariance matrix calculated by fitter. ",
                    "methods": [
                      "__init__(self, cov_matrix, param_names)",
                      "pprint(self, max_lines, round_val)",
                      "__repr__(self)",
                      "__getitem__(self, params)"
                    ]
                  },
                  {
                    "name": "StandardDeviations()",
                    "docstring": "Class for fitting uncertainties.",
                    "methods": [
                      "__init__(self, cov_matrix, param_names)",
                      "_calc_stds(self, cov_matrix)",
                      "pprint(self, max_lines, round_val)",
                      "__repr__(self)",
                      "__getitem__(self, param)"
                    ]
                  },
                  {
                    "name": "ModelsError(Exception)",
                    "docstring": "Base class for model exceptions",
                    "methods": []
                  },
                  {
                    "name": "ModelLinearityError(ModelsError)",
                    "docstring": "Raised when a non-linear model is passed to a linear fitter.",
                    "methods": []
                  },
                  {
                    "name": "UnsupportedConstraintError(ModelsError, ValueError)",
                    "docstring": "Raised when a fitter does not support a type of constraint.",
                    "methods": []
                  },
                  {
                    "name": "_FitterMeta(abc.ABCMeta)",
                    "docstring": "Currently just provides a registry for all Fitter classes.",
                    "methods": [
                      "__new__(mcls, name, bases, members)"
                    ]
                  },
                  {
                    "name": "Fitter()",
                    "docstring": "Base class for all fitters.\n\nParameters\n----------\noptimizer : callable\n    A callable implementing an optimization algorithm\nstatistic : callable\n    Statistic function",
                    "methods": [
                      "__init__(self, optimizer, statistic)",
                      "objective_function(self, fps)",
                      "_add_fitting_uncertainties()",
                      "__call__(self)"
                    ]
                  },
                  {
                    "name": "LinearLSQFitter()",
                    "docstring": "A class performing a linear least square fitting.\nUses `numpy.linalg.lstsq` to do the fitting.\nGiven a model and data, fits the model to the data and changes the\nmodel's parameters. Keeps a dictionary of auxiliary fitting information.\nNotes\n-----\nNote that currently LinearLSQFitter does not support compound models.",
                    "methods": [
                      "__init__(self, calc_uncertainties)",
                      "_is_invertible(m)",
                      "_add_fitting_uncertainties(self, model, a, n_coeff, x, y, z, resids)",
                      "_deriv_with_constraints(model, param_indices, x, y)",
                      "_map_domain_window(self, model, x, y)",
                      "__call__(self, model, x, y, z, weights, rcond)"
                    ]
                  },
                  {
                    "name": "FittingWithOutlierRemoval()",
                    "docstring": "This class combines an outlier removal technique with a fitting procedure.\nBasically, given a maximum number of iterations ``niter``, outliers are\nremoved and fitting is performed for each iteration, until no new outliers\nare found or ``niter`` is reached.\n\nParameters\n----------\nfitter : `Fitter`\n    An instance of any Astropy fitter, i.e., LinearLSQFitter,\n    LevMarLSQFitter, SLSQPLSQFitter, SimplexLSQFitter, JointFitter. For\n    model set fitting, this must understand masked input data (as\n    indicated by the fitter class attribute ``supports_masked_input``).\noutlier_func : callable\n    A function for outlier removal.\n    If this accepts an ``axis`` parameter like the `numpy` functions, the\n    appropriate value will be supplied automatically when fitting model\n    sets (unless overridden in ``outlier_kwargs``), to find outliers for\n    each model separately; otherwise, the same filtering must be performed\n    in a loop over models, which is almost an order of magnitude slower.\nniter : int, optional\n    Maximum number of iterations.\noutlier_kwargs : dict, optional\n    Keyword arguments for outlier_func.\n\nAttributes\n----------\nfit_info : dict\n    The ``fit_info`` (if any) from the last iteration of the wrapped\n    ``fitter`` during the most recent fit. An entry is also added with the\n    keyword ``niter`` that records the actual number of fitting iterations\n    performed (as opposed to the user-specified maximum).",
                    "methods": [
                      "__init__(self, fitter, outlier_func, niter)",
                      "__str__(self)",
                      "__repr__(self)",
                      "__call__(self, model, x, y, z, weights)"
                    ]
                  },
                  {
                    "name": "LevMarLSQFitter()",
                    "docstring": "Levenberg-Marquardt algorithm and least squares statistic.\n\nAttributes\n----------\nfit_info : dict\n    The `scipy.optimize.leastsq` result for the most recent fit (see\n    notes).\n\nNotes\n-----\nThe ``fit_info`` dictionary contains the values returned by\n`scipy.optimize.leastsq` for the most recent fit, including the values from\nthe ``infodict`` dictionary it returns. See the `scipy.optimize.leastsq`\ndocumentation for details on the meaning of these values. Note that the\n``x`` return value is *not* included (as it is instead the parameter values\nof the returned model).\nAdditionally, one additional element of ``fit_info`` is computed whenever a\nmodel is fit, with the key 'param_cov'. The corresponding value is the\ncovariance matrix of the parameters as a 2D numpy array.  The order of the\nmatrix elements matches the order of the parameters in the fitted model\n(i.e., the same order as ``model.param_names``).",
                    "methods": [
                      "__init__(self, calc_uncertainties)",
                      "objective_function(self, fps)",
                      "_add_fitting_uncertainties(model, cov_matrix)",
                      "__call__(self, model, x, y, z, weights, maxiter, acc, epsilon, estimate_jacobian)",
                      "_wrap_deriv(params, model, weights, x, y, z)"
                    ]
                  },
                  {
                    "name": "SLSQPLSQFitter(Fitter)",
                    "docstring": "Sequential Least Squares Programming (SLSQP) optimization algorithm and\nleast squares statistic.\n\nRaises\n------\nModelLinearityError\n    A linear model is passed to a nonlinear fitter\n\nNotes\n-----\nSee also the `~astropy.modeling.optimizers.SLSQP` optimizer.",
                    "methods": [
                      "__init__(self)",
                      "__call__(self, model, x, y, z, weights)"
                    ]
                  },
                  {
                    "name": "SimplexLSQFitter(Fitter)",
                    "docstring": "Simplex algorithm and least squares statistic.\n\nRaises\n------\n`ModelLinearityError`\n    A linear model is passed to a nonlinear fitter",
                    "methods": [
                      "__init__(self)",
                      "__call__(self, model, x, y, z, weights)"
                    ]
                  },
                  {
                    "name": "JointFitter()",
                    "docstring": "Fit models which share a parameter.\nFor example, fit two gaussians to two data sets but keep\nthe FWHM the same.\n\nParameters\n----------\nmodels : list\n    a list of model instances\njointparameters : list\n    a list of joint parameters\ninitvals : list\n    a list of initial values",
                    "methods": [
                      "__init__(self, models, jointparameters, initvals)",
                      "model_to_fit_params(self)",
                      "objective_function(self, fps)",
                      "_verify_input(self)",
                      "__call__(self)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "fitter_unit_support(func)",
                    "content": "def fitter_unit_support(func):\n    \"\"\"\n    This is a decorator that can be used to add support for dealing with\n    quantities to any __call__ method on a fitter which may not support\n    quantities itself. This is done by temporarily removing units from all\n...\n        else:\n\n            return func(self, model, x, y, z=z, **kwargs)\n\n    return wrapper"
                  },
                  {
                    "name": "_convert_input(x, y, z, n_models, model_set_axis)",
                    "content": "def _convert_input(x, y, z=None, n_models=1, model_set_axis=0):\n    \"\"\"Convert inputs to float arrays.\"\"\"\n\n    x = np.asanyarray(x, dtype=float)\n    y = np.asanyarray(y, dtype=float)\n...\n    else:\n        if not (x.shape == y.shape == data_shape):\n            raise ValueError(\"x, y and z should have the same shape\")\n        farg = (x, y, z)\n    return farg"
                  },
                  {
                    "name": "fitter_to_model_params(model, fps)",
                    "content": "def fitter_to_model_params(model, fps):\n    \"\"\"\n    Constructs the full list of model parameters from the fitted and\n    constrained parameters.\n    \"\"\"\n...\n\n                # To handle multiple tied constraints, model parameters\n                # need to be updated after each iteration.\n                parameters[slice_] = value\n                model._array_to_parameters()"
                  },
                  {
                    "name": "_fitter_to_model_params(model, fps)",
                    "content": "def _fitter_to_model_params(model, fps):\n    return fitter_to_model_params(model, fps)"
                  },
                  {
                    "name": "model_to_fit_params(model)",
                    "content": "def model_to_fit_params(model):\n    \"\"\"\n    Convert a model instance's parameter array to an array that can be used\n    with a fitter that doesn't natively support fixed or tied parameters.\n    In particular, it removes fixed/tied parameters from the parameter\n...\n                slice_ = param_metrics[name]['slice']\n                del params[slice_]\n                del fitparam_indices[idx]\n        return (np.array(params), fitparam_indices)\n    return (model.parameters, fitparam_indices)"
                  },
                  {
                    "name": "_model_to_fit_params(model)",
                    "content": "def _model_to_fit_params(model):\n    return model_to_fit_params(model)"
                  },
                  {
                    "name": "_validate_constraints(supported_constraints, model)",
                    "content": "def _validate_constraints(supported_constraints, model):\n    \"\"\"Make sure model constraints are supported by the current fitter.\"\"\"\n\n    message = 'Optimizer cannot handle {0} constraints.'\n\n...\n    if model.eqcons and 'eqcons' not in supported_constraints:\n        raise UnsupportedConstraintError(message.format('equality'))\n\n    if model.ineqcons and 'ineqcons' not in supported_constraints:\n        raise UnsupportedConstraintError(message.format('inequality'))"
                  },
                  {
                    "name": "_validate_model(model, supported_constraints)",
                    "content": "def _validate_model(model, supported_constraints):\n    \"\"\"\n    Check that model and fitter are compatible and return a copy of the model.\n    \"\"\"\n\n...\n                         \"one data set at a time.\")\n    _validate_constraints(supported_constraints, model)\n\n    model_copy = model.copy()\n    return model_copy"
                  },
                  {
                    "name": "populate_entry_points(entry_points)",
                    "content": "def populate_entry_points(entry_points):\n    \"\"\"\n    This injects entry points into the `astropy.modeling.fitting` namespace.\n    This provides a means of inserting a fitting routine without requirement\n    of it being merged into astropy's core.\n...\n                    __all__.append(name)\n                else:\n                    warnings.warn(AstropyUserWarning(\n                        'Modeling entry point {} expected to extend '\n                        'astropy.modeling.Fitter' .format(name)))"
                  },
                  {
                    "name": "_populate_ep()",
                    "content": "def _populate_ep():\n    # TODO: Exclusively use select when Python minversion is 3.10\n    ep = entry_points()\n    if hasattr(ep, 'select'):\n        populate_entry_points(ep.select(group='astropy.modeling'))\n    else:\n        populate_entry_points(ep.get('astropy.modeling', []))"
                  }
                ]
              },
              {
                "file_path": "astropy/convolution/convolve.py",
                "module_docstring": null,
                "classes": [],
                "functions": [
                  {
                    "name": "_next_fast_lengths(shape)",
                    "content": "def _next_fast_lengths(shape):\n    \"\"\"\n    Find optimal or good sizes to pad an array of ``shape`` to for better\n    performance with `numpy.fft.*fft` and `scipy.fft.*fft`.\n    Calculated directly with `scipy.fft.next_fast_len`, if available; otherwise\n...\n                break\n        else:\n            raise ValueError(f'No next fast length for {j} found in list of _good_sizes '\n                             f'<= {_good_sizes[-1] * scale}.')\n    return newshape"
                  },
                  {
                    "name": "_copy_input_if_needed(input, dtype, order, nan_treatment, mask, fill_value)",
                    "content": "def _copy_input_if_needed(input, dtype=float, order='C', nan_treatment=None,\n                          mask=None, fill_value=None):\n    # Alias input\n    input = input.array if isinstance(input, Kernel) else input\n    # strip quantity attributes\n...\n            output = np.array(input, dtype=dtype, copy=False, order=order, subok=True)\n    except (TypeError, ValueError) as e:\n        raise TypeError('input should be a Numpy array or something '\n                        'convertible into a float array', e)\n    return output"
                  },
                  {
                    "name": "convolve(array, kernel, boundary, fill_value, nan_treatment, normalize_kernel, mask, preserve_nan, normalization_zero_tol)",
                    "content": "def convolve(array, kernel, boundary='fill', fill_value=0.,\n             nan_treatment='interpolate', normalize_kernel=True, mask=None,\n             preserve_nan=False, normalization_zero_tol=1e-8):\n    \"\"\"\n    Convolve an array with a kernel.\n...\n            return result.astype(array_dtype, copy=False)\n        except TypeError:\n            return result.astype(array_dtype)\n    else:\n        return result"
                  },
                  {
                    "name": "convolve_fft(array, kernel, boundary, fill_value, nan_treatment, normalize_kernel, normalization_zero_tol, preserve_nan, mask, crop, return_fft, fft_pad, psf_pad, min_wt, allow_huge, fftn, ifftn, complex_dtype, dealias)",
                    "content": "def convolve_fft(array, kernel, boundary='fill', fill_value=0.,\n                 nan_treatment='interpolate', normalize_kernel=True,\n                 normalization_zero_tol=1e-8,\n                 preserve_nan=False, mask=None, crop=True, return_fft=False,\n                 fft_pad=None, psf_pad=None, min_wt=0.0, allow_huge=False,\n...\n    if crop:\n        result = rifft[arrayslices].real\n        return result\n    else:\n        return rifft.real"
                  },
                  {
                    "name": "interpolate_replace_nans(array, kernel, convolve)",
                    "content": "def interpolate_replace_nans(array, kernel, convolve=convolve, **kwargs):\n    \"\"\"\n    Given a data set containing NaNs, replace the NaNs by interpolating from\n    neighboring data points with a given kernel.\n\n...\n\n    isnan = np.isnan(array)\n    newarray[isnan] = convolved[isnan]\n\n    return newarray"
                  },
                  {
                    "name": "convolve_models(model, kernel, mode)",
                    "content": "def convolve_models(model, kernel, mode='convolve_fft', **kwargs):\n    \"\"\"\n    Convolve two models using `~astropy.convolution.convolve_fft`.\n\n    Parameters\n...\n        operator = SPECIAL_OPERATORS.add('convolve', partial(convolve, **kwargs))\n    else:\n        raise ValueError(f'Mode {mode} is not supported.')\n\n    return CompoundModel(operator, model, kernel)"
                  },
                  {
                    "name": "convolve_models_fft(model, kernel, bounding_box, resolution, cache)",
                    "content": "def convolve_models_fft(model, kernel, bounding_box, resolution, cache=True, **kwargs):\n    \"\"\"\n    Convolve two models using `~astropy.convolution.convolve_fft`.\n\n    Parameters\n...\n    \"\"\"\n\n    operator = SPECIAL_OPERATORS.add('convolve_fft', partial(convolve_fft, **kwargs))\n\n    return Convolution(operator, model, kernel, bounding_box, resolution, cache)"
                  }
                ]
              },
              {
                "file_path": "astropy/wcs/wcs.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "NoConvergence(Exception)",
                    "docstring": "An error class used to report non-convergence and/or divergence\nof numerical methods. It is used to report errors in the\niterative solution used by\nthe :py:meth:`~astropy.wcs.WCS.all_world2pix`.\n\nAttributes\n----------\n\nbest_solution : `numpy.ndarray`\n    Best solution achieved by the numerical method.\n\naccuracy : `numpy.ndarray`\n    Accuracy of the ``best_solution``.\n\nniter : `int`\n    Number of iterations performed by the numerical method\n    to compute ``best_solution``.\n\ndivergent : None, `numpy.ndarray`\n    Indices of the points in ``best_solution`` array\n    for which the solution appears to be divergent. If the\n    solution does not diverge, ``divergent`` will be set to `None`.\n\nslow_conv : None, `numpy.ndarray`\n    Indices of the solutions in ``best_solution`` array\n    for which the solution failed to converge within the\n    specified maximum number of iterations. If there are no\n    non-converging solutions (i.e., if the required accuracy\n    has been achieved for all input data points)\n    then ``slow_conv`` will be set to `None`.",
                    "methods": [
                      "__init__(self)"
                    ]
                  },
                  {
                    "name": "FITSFixedWarning(AstropyWarning)",
                    "docstring": "The warning raised when the contents of the FITS header have been\nmodified to be standards compliant.",
                    "methods": []
                  },
                  {
                    "name": "WCS(FITSWCSAPIMixin, WCSBase)",
                    "docstring": "WCS objects perform standard WCS transformations, and correct for\n`SIP`_ and `distortion paper`_ table-lookup transformations, based\non the WCS keywords and supplementary data read from a FITS file.\n\nSee also: https://docs.astropy.org/en/stable/wcs/\n\nParameters\n----------\nheader : `~astropy.io.fits.Header`, `~astropy.io.fits.hdu.image.PrimaryHDU`, `~astropy.io.fits.hdu.image.ImageHDU`, str, dict-like, or None, optional\n    If *header* is not provided or None, the object will be\n    initialized to default values.\n\nfobj : `~astropy.io.fits.HDUList`, optional\n    It is needed when header keywords point to a `distortion\n    paper`_ lookup table stored in a different extension.\n\nkey : str, optional\n    The name of a particular WCS transform to use.  This may be\n    either ``' '`` or ``'A'``-``'Z'`` and corresponds to the\n    ``\"a\"`` part of the ``CTYPEia`` cards.  *key* may only be\n    provided if *header* is also provided.\n\nminerr : float, optional\n    The minimum value a distortion correction must have in order\n    to be applied. If the value of ``CQERRja`` is smaller than\n    *minerr*, the corresponding distortion is not applied.\n\nrelax : bool or int, optional\n    Degree of permissiveness:\n\n    - `True` (default): Admit all recognized informal extensions\n      of the WCS standard.\n\n    - `False`: Recognize only FITS keywords defined by the\n      published WCS standard.\n\n    - `int`: a bit field selecting specific extensions to accept.\n      See :ref:`astropy:relaxread` for details.\n\nnaxis : int or sequence, optional\n    Extracts specific coordinate axes using\n    :meth:`~astropy.wcs.Wcsprm.sub`.  If a header is provided, and\n    *naxis* is not ``None``, *naxis* will be passed to\n    :meth:`~astropy.wcs.Wcsprm.sub` in order to select specific\n    axes from the header.  See :meth:`~astropy.wcs.Wcsprm.sub` for\n    more details about this parameter.\n\nkeysel : sequence of str, optional\n    A sequence of flags used to select the keyword types\n    considered by wcslib.  When ``None``, only the standard image\n    header keywords are considered (and the underlying wcspih() C\n    function is called).  To use binary table image array or pixel\n    list keywords, *keysel* must be set.\n\n    Each element in the list should be one of the following\n    strings:\n\n    - 'image': Image header keywords\n\n    - 'binary': Binary table image array keywords\n\n    - 'pixel': Pixel list keywords\n\n    Keywords such as ``EQUIna`` or ``RFRQna`` that are common to\n    binary table image arrays and pixel lists (including\n    ``WCSNna`` and ``TWCSna``) are selected by both 'binary' and\n    'pixel'.\n\ncolsel : sequence of int, optional\n    A sequence of table column numbers used to restrict the WCS\n    transformations considered to only those pertaining to the\n    specified columns.  If `None`, there is no restriction.\n\nfix : bool, optional\n    When `True` (default), call `~astropy.wcs.Wcsprm.fix` on\n    the resulting object to fix any non-standard uses in the\n    header.  `FITSFixedWarning` Warnings will be emitted if any\n    changes were made.\n\ntranslate_units : str, optional\n    Specify which potentially unsafe translations of non-standard\n    unit strings to perform.  By default, performs none.  See\n    `WCS.fix` for more information about this parameter.  Only\n    effective when ``fix`` is `True`.\n\nRaises\n------\nMemoryError\n     Memory allocation failed.\n\nValueError\n     Invalid key.\n\nKeyError\n     Key not found in FITS header.\n\nValueError\n     Lookup table distortion present in the header but *fobj* was\n     not provided.\n\nNotes\n-----\n\n1. astropy.wcs supports arbitrary *n* dimensions for the core WCS\n   (the transformations handled by WCSLIB).  However, the\n   `distortion paper`_ lookup table and `SIP`_ distortions must be\n   two dimensional.  Therefore, if you try to create a WCS object\n   where the core WCS has a different number of dimensions than 2\n   and that object also contains a `distortion paper`_ lookup\n   table or `SIP`_ distortion, a `ValueError`\n   exception will be raised.  To avoid this, consider using the\n   *naxis* kwarg to select two dimensions from the core WCS.\n\n2. The number of coordinate axes in the transformation is not\n   determined directly from the ``NAXIS`` keyword but instead from\n   the highest of:\n\n       - ``NAXIS`` keyword\n\n       - ``WCSAXESa`` keyword\n\n       - The highest axis number in any parameterized WCS keyword.\n         The keyvalue, as well as the keyword, must be\n         syntactically valid otherwise it will not be considered.\n\n   If none of these keyword types is present, i.e. if the header\n   only contains auxiliary WCS keywords for a particular\n   coordinate representation, then no coordinate description is\n   constructed for it.\n\n   The number of axes, which is set as the ``naxis`` member, may\n   differ for different coordinate representations of the same\n   image.\n\n3. When the header includes duplicate keywords, in most cases the\n   last encountered is used.\n\n4. `~astropy.wcs.Wcsprm.set` is called immediately after\n   construction, so any invalid keywords or transformations will\n   be raised by the constructor, not when subsequently calling a\n   transformation method.",
                    "methods": [
                      "__init__(self, header, fobj, key, minerr, relax, naxis, keysel, colsel, fix, translate_units, _do_set)",
                      "__copy__(self)",
                      "__deepcopy__(self, memo)",
                      "copy(self)",
                      "deepcopy(self)",
                      "sub(self, axes)",
                      "_fix_scamp(self)",
                      "fix(self, translate_units, naxis)",
                      "calc_footprint(self, header, undistort, axes, center)",
                      "_read_det2im_kw(self, header, fobj, err)",
                      "_read_d2im_old_format(self, header, fobj, axiscorr)",
                      "_write_det2im(self, hdulist)",
                      "_read_distortion_kw(self, header, fobj, dist, err)",
                      "_write_distortion_kw(self, hdulist, dist)",
                      "_remove_sip_kw(self, header)",
                      "_read_sip_kw(self, header, wcskey)",
                      "_write_sip_kw(self)",
                      "_denormalize_sky(self, sky)",
                      "_normalize_sky(self, sky)",
                      "_array_converter(self, func, sky)",
                      "all_pix2world(self)",
                      "wcs_pix2world(self)",
                      "_all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)",
                      "all_world2pix(self)",
                      "wcs_world2pix(self)",
                      "pix2foc(self)",
                      "p4_pix2foc(self)",
                      "det2im(self)",
                      "sip_pix2foc(self)",
                      "sip_foc2pix(self)",
                      "proj_plane_pixel_scales(self)",
                      "proj_plane_pixel_area(self)",
                      "to_fits(self, relax, key)",
                      "to_header(self, relax, key)",
                      "_fix_ctype(self, header, add_sip, log_message)",
                      "to_header_string(self, relax)",
                      "footprint_to_file(self, filename, color, width, coordsys)",
                      "_get_naxis(self, header)",
                      "printwcs(self)",
                      "__repr__(self)",
                      "get_axis_types(self)",
                      "__reduce__(self)",
                      "dropaxis(self, dropax)",
                      "swapaxes(self, ax0, ax1)",
                      "reorient_celestial_first(self)",
                      "slice(self, view, numpy_order)",
                      "__getitem__(self, item)",
                      "__iter__(self)",
                      "axis_type_names(self)",
                      "celestial(self)",
                      "is_celestial(self)",
                      "has_celestial(self)",
                      "spectral(self)",
                      "is_spectral(self)",
                      "has_spectral(self)",
                      "has_distortion(self)",
                      "pixel_scale_matrix(self)",
                      "footprint_contains(self, coord)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "_parse_keysel(keysel)",
                    "content": "def _parse_keysel(keysel):\n    keysel_flags = 0\n    if keysel is not None:\n        for element in keysel:\n            if element.lower() == 'image':\n...\n                    \"and/or 'pixel'\")\n    else:\n        keysel_flags = -1\n\n    return keysel_flags"
                  },
                  {
                    "name": "__WCS_unpickle__(cls, dct, fits_data)",
                    "content": "def __WCS_unpickle__(cls, dct, fits_data):\n    \"\"\"\n    Unpickles a WCS object from a serialized FITS string.\n    \"\"\"\n\n...\n    wcskey = dct.pop('_alt_wcskey', ' ')\n    WCS.__init__(self, hdulist[0].header, hdulist, key=wcskey, **kwargs)\n    self.pixel_bounds = dct.get('_pixel_bounds', None)\n\n    return self"
                  },
                  {
                    "name": "find_all_wcs(header, relax, keysel, fix, translate_units, _do_set)",
                    "content": "def find_all_wcs(header, relax=True, keysel=None, fix=True,\n                 translate_units='',\n                 _do_set=True):\n    \"\"\"\n    Find all the WCS transformations in the given header.\n...\n\n        if _do_set:\n            subresult.wcs.set()\n\n    return result"
                  },
                  {
                    "name": "validate(source)",
                    "content": "def validate(source):\n    \"\"\"\n    Prints a WCS validation report for the given FITS file.\n\n    Parameters\n...\n                    wcs_results.append(str(e))\n\n                wcs_results.extend([str(x.message) for x in warning_lines])\n\n    return results"
                  }
                ]
              },
              {
                "file_path": "astropy/timeseries/periodograms/lombscargle/core.py",
                "module_docstring": "Main Lomb-Scargle Implementation",
                "classes": [
                  {
                    "name": "LombScargle(BasePeriodogram)",
                    "docstring": "Compute the Lomb-Scargle Periodogram.\n\nThis implementations here are based on code presented in [1]_ and [2]_;\nif you use this functionality in an academic application, citation of\nthose works would be appreciated.\n\nParameters\n----------\nt : array-like or `~astropy.units.Quantity` ['time']\n    sequence of observation times\ny : array-like or `~astropy.units.Quantity`\n    sequence of observations associated with times t\ndy : float, array-like, or `~astropy.units.Quantity`, optional\n    error or sequence of observational errors associated with times t\nfit_mean : bool, optional\n    if True, include a constant offset as part of the model at each\n    frequency. This can lead to more accurate results, especially in the\n    case of incomplete phase coverage.\ncenter_data : bool, optional\n    if True, pre-center the data by subtracting the weighted mean\n    of the input data. This is especially important if fit_mean = False\nnterms : int, optional\n    number of terms to use in the Fourier fit\nnormalization : {'standard', 'model', 'log', 'psd'}, optional\n    Normalization to use for the periodogram.\n\nExamples\n--------\nGenerate noisy periodic data:\n\n>>> rand = np.random.default_rng(42)\n>>> t = 100 * rand.random(100)\n>>> y = np.sin(2 * np.pi * t) + rand.standard_normal(100)\n\nCompute the Lomb-Scargle periodogram on an automatically-determined\nfrequency grid & find the frequency of max power:\n\n>>> frequency, power = LombScargle(t, y).autopower()\n>>> frequency[np.argmax(power)]  # doctest: +FLOAT_CMP\n1.0007641728995051\n\nCompute the Lomb-Scargle periodogram at a user-specified frequency grid:\n\n>>> freq = np.arange(0.8, 1.3, 0.1)\n>>> LombScargle(t, y).power(freq)  # doctest: +FLOAT_CMP\narray([0.0792948 , 0.01778874, 0.25328167, 0.01064157, 0.01471387])\n\nIf the inputs are astropy Quantities with units, the units will be\nvalidated and the outputs will also be Quantities with appropriate units:\n\n>>> from astropy import units as u\n>>> t = t * u.s\n>>> y = y * u.mag\n>>> frequency, power = LombScargle(t, y).autopower()\n>>> frequency.unit\nUnit(\"1 / s\")\n>>> power.unit\nUnit(dimensionless)\n\nNote here that the Lomb-Scargle power is always a unitless quantity,\nbecause it is related to the :math:`\\chi^2` of the best-fit periodic\nmodel at each frequency.\n\nReferences\n----------\n.. [1] Vanderplas, J., Connolly, A. Ivezic, Z. & Gray, A. *Introduction to\n    astroML: Machine learning for astrophysics*. Proceedings of the\n    Conference on Intelligent Data Understanding (2012)\n.. [2] VanderPlas, J. & Ivezic, Z. *Periodograms for Multiband Astronomical\n    Time Series*. ApJ 812.1:18 (2015)",
                    "methods": [
                      "__init__(self, t, y, dy, fit_mean, center_data, nterms, normalization)",
                      "_validate_inputs(self, t, y, dy)",
                      "_validate_frequency(self, frequency)",
                      "_validate_t(self, t)",
                      "_power_unit(self, norm)",
                      "autofrequency(self, samples_per_peak, nyquist_factor, minimum_frequency, maximum_frequency, return_freq_limits)",
                      "autopower(self, method, method_kwds, normalization, samples_per_peak, nyquist_factor, minimum_frequency, maximum_frequency)",
                      "power(self, frequency, normalization, method, assume_regular_frequency, method_kwds)",
                      "_as_relative_time(self, name, times)",
                      "model(self, t, frequency)",
                      "offset(self)",
                      "model_parameters(self, frequency, units)",
                      "design_matrix(self, frequency, t)",
                      "distribution(self, power, cumulative)",
                      "false_alarm_probability(self, power, method, samples_per_peak, nyquist_factor, minimum_frequency, maximum_frequency, method_kwds)",
                      "false_alarm_level(self, false_alarm_probability, method, samples_per_peak, nyquist_factor, minimum_frequency, maximum_frequency, method_kwds)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "has_units(obj)",
                    "content": "def has_units(obj):\n    return hasattr(obj, 'unit')"
                  },
                  {
                    "name": "get_unit(obj)",
                    "content": "def get_unit(obj):\n    return getattr(obj, 'unit', 1)"
                  },
                  {
                    "name": "strip_units()",
                    "content": "def strip_units(*arrs):\n    strip = lambda a: None if a is None else np.asarray(a)\n    if len(arrs) == 1:\n        return strip(arrs[0])\n    else:\n        return map(strip, arrs)"
                  }
                ]
              },
              {
                "file_path": "astropy/units/quantity.py",
                "module_docstring": "This module defines the `Quantity` object, which represents a number with some\nassociated units. `Quantity` objects support operations like ordinary numbers,\nbut will deal with unit conversions internally.",
                "classes": [
                  {
                    "name": "Conf(_config.ConfigNamespace)",
                    "docstring": "Configuration parameters for Quantity",
                    "methods": []
                  },
                  {
                    "name": "QuantityIterator()",
                    "docstring": "Flat iterator object to iterate over Quantities\n\nA `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\n``q``.  It allows iterating over the array as if it were a 1-D array,\neither in a for-loop or by calling its `next` method.\n\nIteration is done in C-contiguous style, with the last index varying the\nfastest. The iterator can also be indexed using basic slicing or\nadvanced indexing.\n\nSee Also\n--------\nQuantity.flatten : Returns a flattened copy of an array.\n\nNotes\n-----\n`QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\nis not exported by the `~astropy.units` module.  Instead of\ninstantiating a `QuantityIterator` directly, use `Quantity.flat`.",
                    "methods": [
                      "__init__(self, q)",
                      "__iter__(self)",
                      "__getitem__(self, indx)",
                      "__setitem__(self, index, value)",
                      "__next__(self)",
                      "__len__(self)",
                      "base(self)",
                      "coords(self)",
                      "index(self)",
                      "copy(self)"
                    ]
                  },
                  {
                    "name": "QuantityInfoBase(ParentDtypeInfo)",
                    "docstring": null,
                    "methods": [
                      "default_format(val)",
                      "possible_string_format_functions(format_)"
                    ]
                  },
                  {
                    "name": "QuantityInfo(QuantityInfoBase)",
                    "docstring": "Container for meta information like name, description, format.  This is\nrequired when the object is used as a mixin column within a table, but can\nbe used as a general way to store meta information.",
                    "methods": [
                      "new_like(self, cols, length, metadata_conflicts, name)",
                      "get_sortable_arrays(self)"
                    ]
                  },
                  {
                    "name": "Quantity(np.ndarray)",
                    "docstring": "A `~astropy.units.Quantity` represents a number with some associated unit.\n\nSee also: https://docs.astropy.org/en/stable/units/quantity.html\n\nParameters\n----------\nvalue : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\n    The numerical value of this quantity in the units given by unit.  If a\n    `Quantity` or sequence of them (or any other valid object with a\n    ``unit`` attribute), creates a new `Quantity` object, converting to\n    `unit` units as needed.  If a string, it is converted to a number or\n    `Quantity`, depending on whether a unit is present.\n\nunit : unit-like\n    An object that represents the unit associated with the input value.\n    Must be an `~astropy.units.UnitBase` object or a string parseable by\n    the :mod:`~astropy.units` package.\n\ndtype : ~numpy.dtype, optional\n    The dtype of the resulting Numpy array or scalar that will\n    hold the value.  If not provided, it is determined from the input,\n    except that any integer and (non-Quantity) object inputs are converted\n    to float by default.\n\ncopy : bool, optional\n    If `True` (default), then the value is copied.  Otherwise, a copy will\n    only be made if ``__array__`` returns a copy, if value is a nested\n    sequence, or if a copy is needed to satisfy an explicitly given\n    ``dtype``.  (The `False` option is intended mostly for internal use,\n    to speed up initialization where a copy is known to have been made.\n    Use with care.)\n\norder : {'C', 'F', 'A'}, optional\n    Specify the order of the array.  As in `~numpy.array`.  This parameter\n    is ignored if the input is a `Quantity` and ``copy=False``.\n\nsubok : bool, optional\n    If `False` (default), the returned array will be forced to be a\n    `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\n    or a subclass appropriate for the unit will be used (such as\n    `~astropy.units.Dex` for ``u.dex(u.AA)``).\n\nndmin : int, optional\n    Specifies the minimum number of dimensions that the resulting array\n    should have.  Ones will be pre-pended to the shape as needed to meet\n    this requirement.  This parameter is ignored if the input is a\n    `Quantity` and ``copy=False``.\n\nRaises\n------\nTypeError\n    If the value provided is not a Python numeric type.\nTypeError\n    If the unit provided is not either a :class:`~astropy.units.Unit`\n    object or a parseable string unit.\n\nNotes\n-----\nQuantities can also be created by multiplying a number or array with a\n:class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\n\nUnless the ``dtype`` argument is explicitly specified, integer\nor (non-Quantity) object inputs are converted to `float` by default.",
                    "methods": [
                      "__class_getitem__(cls, unit_shape_dtype)",
                      "__new__(cls, value, unit, dtype, copy, order, subok, ndmin)",
                      "__array_finalize__(self, obj)",
                      "__array_wrap__(self, obj, context)",
                      "__array_ufunc__(self, function, method)",
                      "_result_as_quantity(self, result, unit, out)",
                      "__quantity_subclass__(self, unit)",
                      "_new_view(self, obj, unit)",
                      "_set_unit(self, unit)",
                      "__deepcopy__(self, memo)",
                      "__reduce__(self)",
                      "__setstate__(self, state)",
                      "_to_value(self, unit, equivalencies)",
                      "to(self, unit, equivalencies, copy)",
                      "to_value(self, unit, equivalencies)",
                      "unit(self)",
                      "equivalencies(self)",
                      "_recursively_apply(self, func)",
                      "si(self)",
                      "cgs(self)",
                      "isscalar(self)",
                      "__dir__(self)",
                      "__getattr__(self, attr)",
                      "__eq__(self, other)",
                      "__ne__(self, other)",
                      "__lshift__(self, other)",
                      "__ilshift__(self, other)",
                      "__rlshift__(self, other)",
                      "__rrshift__(self, other)",
                      "__rshift__(self, other)",
                      "__irshift__(self, other)",
                      "__mul__(self, other)",
                      "__imul__(self, other)",
                      "__rmul__(self, other)",
                      "__truediv__(self, other)",
                      "__itruediv__(self, other)",
                      "__rtruediv__(self, other)",
                      "__pow__(self, other)",
                      "__hash__(self)",
                      "__iter__(self)",
                      "__getitem__(self, key)",
                      "__setitem__(self, i, value)",
                      "__bool__(self)",
                      "__len__(self)",
                      "__float__(self)",
                      "__int__(self)",
                      "__index__(self)",
                      "_unitstr(self)",
                      "to_string(self, unit, precision, format, subfmt)",
                      "__str__(self)",
                      "__repr__(self)",
                      "_repr_latex_(self)",
                      "__format__(self, format_spec)",
                      "decompose(self, bases)",
                      "_decompose(self, allowscaledunits, bases)",
                      "item(self)",
                      "tolist(self)",
                      "_to_own_unit(self, value, check_precision)",
                      "itemset(self)",
                      "tostring(self, order)",
                      "tobytes(self, order)",
                      "tofile(self, fid, sep, format)",
                      "dump(self, file)",
                      "dumps(self)",
                      "fill(self, value)",
                      "flat(self)",
                      "flat(self, value)",
                      "take(self, indices, axis, out, mode)",
                      "put(self, indices, values, mode)",
                      "choose(self, choices, out, mode)",
                      "argsort(self, axis, kind, order)",
                      "searchsorted(self, v)",
                      "argmax(self, axis, out)",
                      "argmin(self, axis, out)",
                      "__array_function__(self, function, types, args, kwargs)",
                      "_not_implemented_or_raise(self, function, types)",
                      "_wrap_function(self, function)",
                      "trace(self, offset, axis1, axis2, dtype, out)",
                      "var(self, axis, dtype, out, ddof, keepdims)",
                      "std(self, axis, dtype, out, ddof, keepdims)",
                      "mean(self, axis, dtype, out, keepdims)",
                      "round(self, decimals, out)",
                      "dot(self, b, out)",
                      "all(self, axis, out)",
                      "any(self, axis, out)",
                      "diff(self, n, axis)",
                      "ediff1d(self, to_end, to_begin)",
                      "nansum(self, axis, out, keepdims)",
                      "insert(self, obj, values, axis)"
                    ]
                  },
                  {
                    "name": "SpecificTypeQuantity(Quantity)",
                    "docstring": "Superclass for Quantities of specific physical type.\n\nSubclasses of these work just like :class:`~astropy.units.Quantity`, except\nthat they are for specific physical types (and may have methods that are\nonly appropriate for that type).  Astropy examples are\n:class:`~astropy.coordinates.Angle` and\n:class:`~astropy.coordinates.Distance`\n\nAt a minimum, subclasses should set ``_equivalent_unit`` to the unit\nassociated with the physical type.",
                    "methods": [
                      "__quantity_subclass__(self, unit)",
                      "_set_unit(self, unit)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "isclose(a, b, rtol, atol, equal_nan)",
                    "content": "def isclose(a, b, rtol=1.e-5, atol=None, equal_nan=False, **kwargs):\n    \"\"\"\n    Return a boolean array where two arrays are element-wise equal\n    within a tolerance.\n\n...\n    --------\n    allclose\n    \"\"\"\n    unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)\n    return np.isclose(*unquantified_args, equal_nan=equal_nan, **kwargs)"
                  },
                  {
                    "name": "allclose(a, b, rtol, atol, equal_nan)",
                    "content": "def allclose(a, b, rtol=1.e-5, atol=None, equal_nan=False, **kwargs) -> bool:\n    \"\"\"\n    Whether two arrays are element-wise equal within a tolerance.\n\n    Parameters\n...\n    --------\n    isclose\n    \"\"\"\n    unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)\n    return np.allclose(*unquantified_args, equal_nan=equal_nan, **kwargs)"
                  },
                  {
                    "name": "_unquantify_allclose_arguments(actual, desired, rtol, atol)",
                    "content": "def _unquantify_allclose_arguments(actual, desired, rtol, atol):\n    actual = Quantity(actual, subok=True, copy=False)\n\n    desired = Quantity(desired, subok=True, copy=False)\n    try:\n...\n        rtol = rtol.to(dimensionless_unscaled)\n    except Exception:\n        raise UnitsError(\"'rtol' should be dimensionless\")\n\n    return actual.value, desired.value, rtol.value, atol.value"
                  }
                ]
              },
              {
                "file_path": "astropy/wcs/docstrings.py",
                "module_docstring": null,
                "classes": [],
                "functions": [
                  {
                    "name": "_fix(content, indent)",
                    "content": "def _fix(content, indent=0):\n    lines = content.split('\\n')\n    indent = '\\n' + ' ' * indent\n    return indent.join(lines)"
                  },
                  {
                    "name": "TWO_OR_MORE_ARGS(naxis, indent)",
                    "content": "def TWO_OR_MORE_ARGS(naxis, indent=0):\n    return _fix(\nf\"\"\"*args\n    There are two accepted forms for the positional arguments:\n\n...\n\n    Here, *origin* is the coordinate in the upper left corner of the\n    image.  In FITS and Fortran standards, this is 1.  In Numpy and C\n    standards this is 0.\n\"\"\", indent)"
                  },
                  {
                    "name": "RETURNS(out_type, indent)",
                    "content": "def RETURNS(out_type, indent=0):\n    return _fix(f\"\"\"result : array\n    Returns the {out_type}.  If the input was a single array and\n    origin, a single array is returned, otherwise a tuple of arrays is\n    returned.\"\"\", indent)"
                  },
                  {
                    "name": "ORIGIN(indent)",
                    "content": "def ORIGIN(indent=0):\n    return _fix(\n\"\"\"\norigin : int\n    Specifies the origin of pixel values.  The Fortran and FITS\n    standards use an origin of 1.  Numpy and C use array indexing with\n    origin at 0.\n\"\"\", indent)"
                  },
                  {
                    "name": "RA_DEC_ORDER(indent)",
                    "content": "def RA_DEC_ORDER(indent=0):\n    return _fix(\n\"\"\"\nra_dec_order : bool, optional\n    When `True` will ensure that world coordinates are always given\n    and returned in as (*ra*, *dec*) pairs, regardless of the order of\n    the axes specified by the in the ``CTYPE`` keywords.  Default is\n    `False`.\n\"\"\", indent)"
                  }
                ]
              },
              {
                "file_path": "astropy/table/column.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "StringTruncateWarning(UserWarning)",
                    "docstring": "Warning class for when a string column is assigned a value\nthat gets truncated because the base (numpy) string length\nis too short.\n\nThis does not inherit from AstropyWarning because we want to use\nstacklevel=2 to show the user where the issue occurred in their code.",
                    "methods": []
                  },
                  {
                    "name": "FalseArray(np.ndarray)",
                    "docstring": "Boolean mask array that is always False.\n\nThis is used to create a stub ``mask`` property which is a boolean array of\n``False`` used by default for mixin columns and corresponding to the mixin\ncolumn data shape.  The ``mask`` looks like a normal numpy array but an\nexception will be raised if ``True`` is assigned to any element.  The\nconsequences of the limitation are most obvious in the high-level table\noperations.\n\nParameters\n----------\nshape : tuple\n    Data shape",
                    "methods": [
                      "__new__(cls, shape)",
                      "__setitem__(self, item, val)"
                    ]
                  },
                  {
                    "name": "ColumnInfo(BaseColumnInfo)",
                    "docstring": "Container for meta information like name, description, format.\n\nThis is required when the object is used as a mixin column within a table,\nbut can be used as a general way to store meta information.",
                    "methods": [
                      "new_like(self, cols, length, metadata_conflicts, name)",
                      "get_sortable_arrays(self)"
                    ]
                  },
                  {
                    "name": "BaseColumn(_ColumnGetitemShim, np.ndarray)",
                    "docstring": null,
                    "methods": [
                      "__new__(cls, data, name, dtype, shape, length, description, unit, format, meta, copy, copy_indices)",
                      "data(self)",
                      "value(self)",
                      "parent_table(self)",
                      "parent_table(self, table)",
                      "copy(self, order, data, copy_data)",
                      "__setstate__(self, state)",
                      "__reduce__(self)",
                      "__array_finalize__(self, obj)",
                      "__array_wrap__(self, out_arr, context)",
                      "name(self)",
                      "name(self, val)",
                      "format(self)",
                      "format(self, format_string)",
                      "descr(self)",
                      "iter_str_vals(self)",
                      "attrs_equal(self, col)",
                      "_formatter(self)",
                      "pformat(self, max_lines, show_name, show_unit, show_dtype, html)",
                      "pprint(self, max_lines, show_name, show_unit, show_dtype)",
                      "more(self, max_lines, show_name, show_unit)",
                      "unit(self)",
                      "unit(self, unit)",
                      "unit(self)",
                      "searchsorted(self, v, side, sorter)",
                      "convert_unit_to(self, new_unit, equivalencies)",
                      "groups(self)",
                      "group_by(self, keys)",
                      "_copy_groups(self, out)",
                      "__repr__(self)",
                      "quantity(self)",
                      "to(self, unit, equivalencies)",
                      "_copy_attrs(self, obj)",
                      "_encode_str(value)",
                      "tolist(self)"
                    ]
                  },
                  {
                    "name": "Column(BaseColumn)",
                    "docstring": "Define a data column for use in a Table object.\n\nParameters\n----------\ndata : list, ndarray, or None\n    Column data values\nname : str\n    Column name and key for reference within Table\ndtype : `~numpy.dtype`-like\n    Data type for column\nshape : tuple or ()\n    Dimensions of a single row element in the column data\nlength : int or 0\n    Number of row elements in column data\ndescription : str or None\n    Full description of column\nunit : str or None\n    Physical unit\nformat : str, None, or callable\n    Format string for outputting column values.  This can be an\n    \"old-style\" (``format % value``) or \"new-style\" (`str.format`)\n    format specification string or a function or any callable object that\n    accepts a single value and returns a string.\nmeta : dict-like or None\n    Meta-data associated with the column\n\nExamples\n--------\nA Column can be created in two different ways:\n\n- Provide a ``data`` value but not ``shape`` or ``length`` (which are\n  inferred from the data).\n\n  Examples::\n\n    col = Column(data=[1, 2], name='name')  # shape=(2,)\n    col = Column(data=[[1, 2], [3, 4]], name='name')  # shape=(2, 2)\n    col = Column(data=[1, 2], name='name', dtype=float)\n    col = Column(data=np.array([1, 2]), name='name')\n    col = Column(data=['hello', 'world'], name='name')\n\n  The ``dtype`` argument can be any value which is an acceptable\n  fixed-size data-type initializer for the numpy.dtype() method.  See\n  `<https://numpy.org/doc/stable/reference/arrays.dtypes.html>`_.\n  Examples include:\n\n  - Python non-string type (float, int, bool)\n  - Numpy non-string type (e.g. np.float32, np.int64, np.bool\\_)\n  - Numpy.dtype array-protocol type strings (e.g. 'i4', 'f8', 'S15')\n\n  If no ``dtype`` value is provide then the type is inferred using\n  ``np.array(data)``.\n\n- Provide ``length`` and optionally ``shape``, but not ``data``\n\n  Examples::\n\n    col = Column(name='name', length=5)\n    col = Column(name='name', dtype=int, length=10, shape=(3,4))\n\n  The default ``dtype`` is ``np.float64``.  The ``shape`` argument is the\n  array shape of a single cell in the column.",
                    "methods": [
                      "__new__(cls, data, name, dtype, shape, length, description, unit, format, meta, copy, copy_indices)",
                      "__setattr__(self, item, value)",
                      "_base_repr_(self, html)",
                      "_repr_html_(self)",
                      "__repr__(self)",
                      "__str__(self)",
                      "__bytes__(self)",
                      "_check_string_truncate(self, value)",
                      "__setitem__(self, index, value)",
                      "insert(self, obj, values, axis)"
                    ]
                  },
                  {
                    "name": "MaskedColumnInfo(ColumnInfo)",
                    "docstring": "Container for meta information like name, description, format.\n\nThis is required when the object is used as a mixin column within a table,\nbut can be used as a general way to store meta information.  In this case\nit just adds the ``mask_val`` attribute.",
                    "methods": [
                      "__init__(self, bound)",
                      "_represent_as_dict(self)"
                    ]
                  },
                  {
                    "name": "MaskedColumn(Column, _MaskedColumnGetitemShim, ma.MaskedArray)",
                    "docstring": "Define a masked data column for use in a Table object.\n\nParameters\n----------\ndata : list, ndarray, or None\n    Column data values\nname : str\n    Column name and key for reference within Table\nmask : list, ndarray or None\n    Boolean mask for which True indicates missing or invalid data\nfill_value : float, int, str, or None\n    Value used when filling masked column elements\ndtype : `~numpy.dtype`-like\n    Data type for column\nshape : tuple or ()\n    Dimensions of a single row element in the column data\nlength : int or 0\n    Number of row elements in column data\ndescription : str or None\n    Full description of column\nunit : str or None\n    Physical unit\nformat : str, None, or callable\n    Format string for outputting column values.  This can be an\n    \"old-style\" (``format % value``) or \"new-style\" (`str.format`)\n    format specification string or a function or any callable object that\n    accepts a single value and returns a string.\nmeta : dict-like or None\n    Meta-data associated with the column\n\nExamples\n--------\nA MaskedColumn is similar to a Column except that it includes ``mask`` and\n``fill_value`` attributes.  It can be created in two different ways:\n\n- Provide a ``data`` value but not ``shape`` or ``length`` (which are\n  inferred from the data).\n\n  Examples::\n\n    col = MaskedColumn(data=[1, 2], name='name')\n    col = MaskedColumn(data=[1, 2], name='name', mask=[True, False])\n    col = MaskedColumn(data=[1, 2], name='name', dtype=float, fill_value=99)\n\n  The ``mask`` argument will be cast as a boolean array and specifies\n  which elements are considered to be missing or invalid.\n\n  The ``dtype`` argument can be any value which is an acceptable\n  fixed-size data-type initializer for the numpy.dtype() method.  See\n  `<https://numpy.org/doc/stable/reference/arrays.dtypes.html>`_.\n  Examples include:\n\n  - Python non-string type (float, int, bool)\n  - Numpy non-string type (e.g. np.float32, np.int64, np.bool\\_)\n  - Numpy.dtype array-protocol type strings (e.g. 'i4', 'f8', 'S15')\n\n  If no ``dtype`` value is provide then the type is inferred using\n  ``np.array(data)``.  When ``data`` is provided then the ``shape``\n  and ``length`` arguments are ignored.\n\n- Provide ``length`` and optionally ``shape``, but not ``data``\n\n  Examples::\n\n    col = MaskedColumn(name='name', length=5)\n    col = MaskedColumn(name='name', dtype=int, length=10, shape=(3,4))\n\n  The default ``dtype`` is ``np.float64``.  The ``shape`` argument is the\n  array shape of a single cell in the column.",
                    "methods": [
                      "__new__(cls, data, name, mask, fill_value, dtype, shape, length, description, unit, format, meta, copy, copy_indices)",
                      "fill_value(self)",
                      "fill_value(self, val)",
                      "data(self)",
                      "filled(self, fill_value)",
                      "insert(self, obj, values, mask, axis)",
                      "_copy_attrs_slice(self, out)",
                      "__setitem__(self, index, value)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "_auto_names(n_cols)",
                    "content": "def _auto_names(n_cols):\n    from . import conf\n    return [str(conf.auto_colname).format(i) for i in range(n_cols)]"
                  },
                  {
                    "name": "col_copy(col, copy_indices)",
                    "content": "def col_copy(col, copy_indices=True):\n    \"\"\"\n    Mixin-safe version of Column.copy() (with copy_data=True).\n\n    Parameters\n...\n            newcol.info.indices = deepcopy(col.info.indices)\n            for index in newcol.info.indices:\n                index.replace_col(col, newcol)\n\n    return newcol"
                  },
                  {
                    "name": "_expand_string_array_for_values(arr, values)",
                    "content": "def _expand_string_array_for_values(arr, values):\n    \"\"\"\n    For string-dtype return a version of ``arr`` that is wide enough for ``values``.\n    If ``arr`` is not string-dtype or does not need expansion then return ``arr``.\n\n...\n        if arr_str_len and values_str_len > arr_str_len:\n            arr_dtype = arr.dtype.byteorder + arr.dtype.kind + str(values_str_len)\n            arr = arr.astype(arr_dtype)\n\n    return arr"
                  },
                  {
                    "name": "_convert_sequence_data_to_array(data, dtype)",
                    "content": "def _convert_sequence_data_to_array(data, dtype=None):\n    \"\"\"Convert N-d sequence-like data to ndarray or MaskedArray.\n\n    This is the core function for converting Python lists or list of lists to a\n    numpy array. This handles embedded np.ma.masked constants in ``data`` along\n...\n        # Use np.array first to convert `data` to ndarray (fast) and then make\n        # masked array from an ndarray with mask (fast) instead of from `data`.\n        np_data = np.ma.array(np.array(data_filled, dtype=dtype), mask=mask)\n\n    return np_data"
                  },
                  {
                    "name": "_make_compare(oper)",
                    "content": "def _make_compare(oper):\n    \"\"\"\n    Make Column comparison methods which encode the ``other`` object to utf-8\n    in the case of a bytestring dtype for Py3+.\n\n...\n        result = getattr(super(Column, self), op)(other)\n        # But we should not return Column instances for this case.\n        return result.data if isinstance(result, Column) else result\n\n    return _compare"
                  }
                ]
              },
              {
                "file_path": "astropy/time/core.py",
                "module_docstring": "The astropy.time package provides functionality for manipulating times and\ndates. Specific emphasis is placed on supporting time scales (e.g. UTC, TAI,\nUT1) and time representations (e.g. JD, MJD, ISO 8601) that are used in\nastronomy.",
                "classes": [
                  {
                    "name": "_LeapSecondsCheck(enum.Enum)",
                    "docstring": null,
                    "methods": []
                  },
                  {
                    "name": "TimeInfo(MixinInfo)",
                    "docstring": "Container for meta information like name, description, format.  This is\nrequired when the object is used as a mixin column within a table, but can\nbe used as a general way to store meta information.",
                    "methods": [
                      "_represent_as_dict_attrs(self)",
                      "__init__(self, bound)",
                      "get_sortable_arrays(self)",
                      "unit(self)",
                      "_construct_from_dict_base(self, map)",
                      "_construct_from_dict(self, map)",
                      "new_like(self, cols, length, metadata_conflicts, name)"
                    ]
                  },
                  {
                    "name": "TimeDeltaInfo(TimeInfo)",
                    "docstring": null,
                    "methods": [
                      "_construct_from_dict(self, map)",
                      "new_like(self, cols, length, metadata_conflicts, name)"
                    ]
                  },
                  {
                    "name": "TimeBase(ShapedLikeNDArray)",
                    "docstring": "Base time class from which Time and TimeDelta inherit.",
                    "methods": [
                      "__getnewargs__(self)",
                      "_init_from_vals(self, val, val2, format, scale, copy, precision, in_subfmt, out_subfmt)",
                      "_get_time_fmt(self, val, val2, format, scale, precision, in_subfmt, out_subfmt)",
                      "writeable(self)",
                      "writeable(self, value)",
                      "format(self)",
                      "format(self, format)",
                      "__repr__(self)",
                      "__str__(self)",
                      "__hash__(self)",
                      "scale(self)",
                      "_set_scale(self, scale)",
                      "precision(self)",
                      "precision(self, val)",
                      "in_subfmt(self)",
                      "in_subfmt(self, val)",
                      "out_subfmt(self)",
                      "out_subfmt(self, val)",
                      "shape(self)",
                      "shape(self, shape)",
                      "_shaped_like_input(self, value)",
                      "jd1(self)",
                      "jd2(self)",
                      "to_value(self, format, subfmt)",
                      "value(self)",
                      "masked(self)",
                      "mask(self)",
                      "insert(self, obj, values, axis)",
                      "__setitem__(self, item, value)",
                      "isclose(self, other, atol)",
                      "copy(self, format)",
                      "replicate(self, format, copy, cls)",
                      "_apply(self, method)",
                      "__copy__(self)",
                      "__deepcopy__(self, memo)",
                      "_advanced_index(self, indices, axis, keepdims)",
                      "argmin(self, axis, out)",
                      "argmax(self, axis, out)",
                      "argsort(self, axis)",
                      "min(self, axis, out, keepdims)",
                      "max(self, axis, out, keepdims)",
                      "ptp(self, axis, out, keepdims)",
                      "sort(self, axis)",
                      "cache(self)",
                      "cache(self)",
                      "__getattr__(self, attr)",
                      "__dir__(self)",
                      "_match_shape(self, val)",
                      "_time_comparison(self, other, op)",
                      "__lt__(self, other)",
                      "__le__(self, other)",
                      "__eq__(self, other)",
                      "__ne__(self, other)",
                      "__gt__(self, other)",
                      "__ge__(self, other)"
                    ]
                  },
                  {
                    "name": "Time(TimeBase)",
                    "docstring": "Represent and manipulate times and dates for astronomy.\n\nA `Time` object is initialized with one or more times in the ``val``\nargument.  The input times in ``val`` must conform to the specified\n``format`` and must correspond to the specified time ``scale``.  The\noptional ``val2`` time input should be supplied only for numeric input\nformats (e.g. JD) where very high precision (better than 64-bit precision)\nis required.\n\nThe allowed values for ``format`` can be listed with::\n\n  >>> list(Time.FORMATS)\n  ['jd', 'mjd', 'decimalyear', 'unix', 'unix_tai', 'cxcsec', 'gps', 'plot_date',\n   'stardate', 'datetime', 'ymdhms', 'iso', 'isot', 'yday', 'datetime64',\n   'fits', 'byear', 'jyear', 'byear_str', 'jyear_str']\n\nSee also: http://docs.astropy.org/en/stable/time/\n\nParameters\n----------\nval : sequence, ndarray, number, str, bytes, or `~astropy.time.Time` object\n    Value(s) to initialize the time or times.  Bytes are decoded as ascii.\nval2 : sequence, ndarray, or number; optional\n    Value(s) to initialize the time or times.  Only used for numerical\n    input, to help preserve precision.\nformat : str, optional\n    Format of input value(s)\nscale : str, optional\n    Time scale of input value(s), must be one of the following:\n    ('tai', 'tcb', 'tcg', 'tdb', 'tt', 'ut1', 'utc')\nprecision : int, optional\n    Digits of precision in string representation of time\nin_subfmt : str, optional\n    Unix glob to select subformats for parsing input times\nout_subfmt : str, optional\n    Unix glob to select subformat for outputting times\nlocation : `~astropy.coordinates.EarthLocation` or tuple, optional\n    If given as an tuple, it should be able to initialize an\n    an EarthLocation instance, i.e., either contain 3 items with units of\n    length for geocentric coordinates, or contain a longitude, latitude,\n    and an optional height for geodetic coordinates.\n    Can be a single location, or one for each input time.\n    If not given, assumed to be the center of the Earth for time scale\n    transformations to and from the solar-system barycenter.\ncopy : bool, optional\n    Make a copy of the input values",
                    "methods": [
                      "__new__(cls, val, val2, format, scale, precision, in_subfmt, out_subfmt, location, copy)",
                      "__init__(self, val, val2, format, scale, precision, in_subfmt, out_subfmt, location, copy)",
                      "_make_value_equivalent(self, item, value)",
                      "now(cls)",
                      "strptime(cls, time_string, format_string)",
                      "strftime(self, format_spec)",
                      "light_travel_time(self, skycoord, kind, location, ephemeris)",
                      "earth_rotation_angle(self, longitude)",
                      "sidereal_time(self, kind, longitude, model)",
                      "_sid_time_or_earth_rot_ang(self, longitude, function, scales, include_tio)",
                      "_call_erfa(self, function, scales)",
                      "get_delta_ut1_utc(self, iers_table, return_status)",
                      "_get_delta_ut1_utc(self, jd1, jd2)",
                      "_set_delta_ut1_utc(self, val)",
                      "_get_delta_tdb_tt(self, jd1, jd2)",
                      "_set_delta_tdb_tt(self, val)",
                      "__sub__(self, other)",
                      "__add__(self, other)",
                      "__radd__(self, other)",
                      "to_datetime(self, timezone)"
                    ]
                  },
                  {
                    "name": "TimeDeltaMissingUnitWarning(AstropyDeprecationWarning)",
                    "docstring": "Warning for missing unit or format in TimeDelta",
                    "methods": []
                  },
                  {
                    "name": "TimeDelta(TimeBase)",
                    "docstring": "Represent the time difference between two times.\n\nA TimeDelta object is initialized with one or more times in the ``val``\nargument.  The input times in ``val`` must conform to the specified\n``format``.  The optional ``val2`` time input should be supplied only for\nnumeric input formats (e.g. JD) where very high precision (better than\n64-bit precision) is required.\n\nThe allowed values for ``format`` can be listed with::\n\n  >>> list(TimeDelta.FORMATS)\n  ['sec', 'jd', 'datetime']\n\nNote that for time differences, the scale can be among three groups:\ngeocentric ('tai', 'tt', 'tcg'), barycentric ('tcb', 'tdb'), and rotational\n('ut1'). Within each of these, the scales for time differences are the\nsame. Conversion between geocentric and barycentric is possible, as there\nis only a scale factor change, but one cannot convert to or from 'ut1', as\nthis requires knowledge of the actual times, not just their difference. For\na similar reason, 'utc' is not a valid scale for a time difference: a UTC\nday is not always 86400 seconds.\n\nSee also:\n\n- https://docs.astropy.org/en/stable/time/\n- https://docs.astropy.org/en/stable/time/index.html#time-deltas\n\nParameters\n----------\nval : sequence, ndarray, number, `~astropy.units.Quantity` or `~astropy.time.TimeDelta` object\n    Value(s) to initialize the time difference(s). Any quantities will\n    be converted appropriately (with care taken to avoid rounding\n    errors for regular time units).\nval2 : sequence, ndarray, number, or `~astropy.units.Quantity`; optional\n    Additional values, as needed to preserve precision.\nformat : str, optional\n    Format of input value(s). For numerical inputs without units,\n    \"jd\" is assumed and values are interpreted as days.\n    A deprecation warning is raised in this case. To avoid the warning,\n    either specify the format or add units to the input values.\nscale : str, optional\n    Time scale of input value(s), must be one of the following values:\n    ('tdb', 'tt', 'ut1', 'tcg', 'tcb', 'tai'). If not given (or\n    ``None``), the scale is arbitrary; when added or subtracted from a\n    ``Time`` instance, it will be used without conversion.\ncopy : bool, optional\n    Make a copy of the input values",
                    "methods": [
                      "__new__(cls, val, val2, format, scale, precision, in_subfmt, out_subfmt, location, copy)",
                      "__init__(self, val, val2, format, scale, copy)",
                      "_get_format(val)",
                      "replicate(self)",
                      "to_datetime(self)",
                      "_set_scale(self, scale)",
                      "_add_sub(self, other, op)",
                      "__add__(self, other)",
                      "__sub__(self, other)",
                      "__radd__(self, other)",
                      "__rsub__(self, other)",
                      "__neg__(self)",
                      "__abs__(self)",
                      "__mul__(self, other)",
                      "__rmul__(self, other)",
                      "__truediv__(self, other)",
                      "__rtruediv__(self, other)",
                      "to(self, unit, equivalencies)",
                      "to_value(self)",
                      "_make_value_equivalent(self, item, value)",
                      "isclose(self, other, atol, rtol)"
                    ]
                  },
                  {
                    "name": "ScaleValueError(Exception)",
                    "docstring": null,
                    "methods": []
                  },
                  {
                    "name": "OperandTypeError(TypeError)",
                    "docstring": null,
                    "methods": [
                      "__init__(self, left, right, op)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "_make_array(val, copy)",
                    "content": "def _make_array(val, copy=False):\n    \"\"\"\n    Take ``val`` and convert/reshape to an array.  If ``copy`` is `True`\n    then copy input values.\n\n...\n        pass\n    else:\n        val = np.asanyarray(val, dtype=np.float64)\n\n    return val"
                  },
                  {
                    "name": "_check_for_masked_and_fill(val, val2)",
                    "content": "def _check_for_masked_and_fill(val, val2):\n    \"\"\"\n    If ``val`` or ``val2`` are masked arrays then fill them and cast\n    to ndarray.\n\n...\n        mask, val = get_as_filled_ndarray(mask, val)\n    if isinstance(val2, np.ma.MaskedArray):\n        mask, val2 = get_as_filled_ndarray(mask, val2)\n\n    return mask, val, val2"
                  },
                  {
                    "name": "_check_leapsec()",
                    "content": "def _check_leapsec():\n    global _LEAP_SECONDS_CHECK\n    if _LEAP_SECONDS_CHECK != _LeapSecondsCheck.DONE:\n        from astropy.utils import iers\n        with _LEAP_SECONDS_LOCK:\n...\n            #    lock to us, so initialization is complete.\n            if _LEAP_SECONDS_CHECK == _LeapSecondsCheck.NOT_STARTED:\n                _LEAP_SECONDS_CHECK = _LeapSecondsCheck.RUNNING\n                update_leap_seconds()\n                _LEAP_SECONDS_CHECK = _LeapSecondsCheck.DONE"
                  },
                  {
                    "name": "update_leap_seconds(files)",
                    "content": "def update_leap_seconds(files=None):\n    \"\"\"If the current ERFA leap second table is out of date, try to update it.\n\n    Uses `astropy.utils.iers.LeapSeconds.auto_open` to try to find an\n    up-to-date table.  See that routine for the definition of \"out of date\".\n...\n\n    except Exception as exc:\n        warn(\"leap-second auto-update failed due to the following \"\n             f\"exception: {exc!r}\", AstropyWarning)\n        return 0"
                  }
                ]
              },
              {
                "file_path": "astropy/coordinates/sky_coordinate.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "SkyCoordInfo(MixinInfo)",
                    "docstring": "Container for meta information like name, description, format.  This is\nrequired when the object is used as a mixin column within a table, but can\nbe used as a general way to store meta information.",
                    "methods": [
                      "default_format(val)",
                      "unit(self)",
                      "_repr_data(self)",
                      "_represent_as_dict(self)",
                      "new_like(self, skycoords, length, metadata_conflicts, name)"
                    ]
                  },
                  {
                    "name": "SkyCoord(ShapedLikeNDArray)",
                    "docstring": "High-level object providing a flexible interface for celestial coordinate\nrepresentation, manipulation, and transformation between systems.\n\nThe `SkyCoord` class accepts a wide variety of inputs for initialization. At\na minimum these must provide one or more celestial coordinate values with\nunambiguous units.  Inputs may be scalars or lists/tuples/arrays, yielding\nscalar or array coordinates (can be checked via ``SkyCoord.isscalar``).\nTypically one also specifies the coordinate frame, though this is not\nrequired. The general pattern for spherical representations is::\n\n  SkyCoord(COORD, [FRAME], keyword_args ...)\n  SkyCoord(LON, LAT, [FRAME], keyword_args ...)\n  SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\n  SkyCoord([FRAME], <lon_attr>=LON, <lat_attr>=LAT, keyword_args ...)\n\nIt is also possible to input coordinate values in other representations\nsuch as cartesian or cylindrical.  In this case one includes the keyword\nargument ``representation_type='cartesian'`` (for example) along with data\nin ``x``, ``y``, and ``z``.\n\nSee also: https://docs.astropy.org/en/stable/coordinates/\n\nExamples\n--------\nThe examples below illustrate common ways of initializing a `SkyCoord`\nobject.  For a complete description of the allowed syntax see the\nfull coordinates documentation.  First some imports::\n\n  >>> from astropy.coordinates import SkyCoord  # High-level coordinates\n  >>> from astropy.coordinates import ICRS, Galactic, FK4, FK5  # Low-level frames\n  >>> from astropy.coordinates import Angle, Latitude, Longitude  # Angles\n  >>> import astropy.units as u\n\nThe coordinate values and frame specification can now be provided using\npositional and keyword arguments::\n\n  >>> c = SkyCoord(10, 20, unit=\"deg\")  # defaults to ICRS frame\n  >>> c = SkyCoord([1, 2, 3], [-30, 45, 8], frame=\"icrs\", unit=\"deg\")  # 3 coords\n\n  >>> coords = [\"1:12:43.2 +31:12:43\", \"1 12 43.2 +31 12 43\"]\n  >>> c = SkyCoord(coords, frame=FK4, unit=(u.hourangle, u.deg), obstime=\"J1992.21\")\n\n  >>> c = SkyCoord(\"1h12m43.2s +1d12m43s\", frame=Galactic)  # Units from string\n  >>> c = SkyCoord(frame=\"galactic\", l=\"1h12m43.2s\", b=\"+1d12m43s\")\n\n  >>> ra = Longitude([1, 2, 3], unit=u.deg)  # Could also use Angle\n  >>> dec = np.array([4.5, 5.2, 6.3]) * u.deg  # Astropy Quantity\n  >>> c = SkyCoord(ra, dec, frame='icrs')\n  >>> c = SkyCoord(frame=ICRS, ra=ra, dec=dec, obstime='2001-01-02T12:34:56')\n\n  >>> c = FK4(1 * u.deg, 2 * u.deg)  # Uses defaults for obstime, equinox\n  >>> c = SkyCoord(c, obstime='J2010.11', equinox='B1965')  # Override defaults\n\n  >>> c = SkyCoord(w=0, u=1, v=2, unit='kpc', frame='galactic',\n  ...              representation_type='cartesian')\n\n  >>> c = SkyCoord([ICRS(ra=1*u.deg, dec=2*u.deg), ICRS(ra=3*u.deg, dec=4*u.deg)])\n\nVelocity components (proper motions or radial velocities) can also be\nprovided in a similar manner::\n\n  >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, radial_velocity=10*u.km/u.s)\n\n  >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, pm_ra_cosdec=2*u.mas/u.yr, pm_dec=1*u.mas/u.yr)\n\nAs shown, the frame can be a `~astropy.coordinates.BaseCoordinateFrame`\nclass or the corresponding string alias.  The frame classes that are built in\nto astropy are `ICRS`, `FK5`, `FK4`, `FK4NoETerms`, and `Galactic`.\nThe string aliases are simply lower-case versions of the class name, and\nallow for creating a `SkyCoord` object and transforming frames without\nexplicitly importing the frame classes.\n\nParameters\n----------\nframe : `~astropy.coordinates.BaseCoordinateFrame` class or string, optional\n    Type of coordinate frame this `SkyCoord` should represent. Defaults to\n    to ICRS if not given or given as None.\nunit : `~astropy.units.Unit`, string, or tuple of :class:`~astropy.units.Unit` or str, optional\n    Units for supplied coordinate values.\n    If only one unit is supplied then it applies to all values.\n    Note that passing only one unit might lead to unit conversion errors\n    if the coordinate values are expected to have mixed physical meanings\n    (e.g., angles and distances).\nobstime : time-like, optional\n    Time(s) of observation.\nequinox : time-like, optional\n    Coordinate frame equinox time.\nrepresentation_type : str or Representation class\n    Specifies the representation, e.g. 'spherical', 'cartesian', or\n    'cylindrical'.  This affects the positional args and other keyword args\n    which must correspond to the given representation.\ncopy : bool, optional\n    If `True` (default), a copy of any coordinate data is made.  This\n    argument can only be passed in as a keyword argument.\n**keyword_args\n    Other keyword arguments as applicable for user-defined coordinate frames.\n    Common options include:\n\n    ra, dec : angle-like, optional\n        RA and Dec for frames where ``ra`` and ``dec`` are keys in the\n        frame's ``representation_component_names``, including `ICRS`,\n        `FK5`, `FK4`, and `FK4NoETerms`.\n    pm_ra_cosdec, pm_dec  : `~astropy.units.Quantity` ['angular speed'], optional\n        Proper motion components, in angle per time units.\n    l, b : angle-like, optional\n        Galactic ``l`` and ``b`` for for frames where ``l`` and ``b`` are\n        keys in the frame's ``representation_component_names``, including\n        the `Galactic` frame.\n    pm_l_cosb, pm_b : `~astropy.units.Quantity` ['angular speed'], optional\n        Proper motion components in the `Galactic` frame, in angle per time\n        units.\n    x, y, z : float or `~astropy.units.Quantity` ['length'], optional\n        Cartesian coordinates values\n    u, v, w : float or `~astropy.units.Quantity` ['length'], optional\n        Cartesian coordinates values for the Galactic frame.\n    radial_velocity : `~astropy.units.Quantity` ['speed'], optional\n        The component of the velocity along the line-of-sight (i.e., the\n        radial direction), in velocity units.",
                    "methods": [
                      "__init__(self)",
                      "frame(self)",
                      "representation_type(self)",
                      "representation_type(self, value)",
                      "representation(self)",
                      "representation(self, value)",
                      "shape(self)",
                      "__eq__(self, value)",
                      "__ne__(self, value)",
                      "_apply(self, method)",
                      "__setitem__(self, item, value)",
                      "insert(self, obj, values, axis)",
                      "is_transformable_to(self, new_frame)",
                      "transform_to(self, frame, merge_attributes)",
                      "apply_space_motion(self, new_obstime, dt)",
                      "_is_name(self, string)",
                      "__getattr__(self, attr)",
                      "__setattr__(self, attr, val)",
                      "__delattr__(self, attr)",
                      "__dir__(self)",
                      "__repr__(self)",
                      "to_string(self, style)",
                      "to_table(self)",
                      "is_equivalent_frame(self, other)",
                      "separation(self, other)",
                      "separation_3d(self, other)",
                      "spherical_offsets_to(self, tocoord)",
                      "spherical_offsets_by(self, d_lon, d_lat)",
                      "directional_offset_by(self, position_angle, separation)",
                      "match_to_catalog_sky(self, catalogcoord, nthneighbor)",
                      "match_to_catalog_3d(self, catalogcoord, nthneighbor)",
                      "search_around_sky(self, searcharoundcoords, seplimit)",
                      "search_around_3d(self, searcharoundcoords, distlimit)",
                      "position_angle(self, other)",
                      "skyoffset_frame(self, rotation)",
                      "get_constellation(self, short_name, constellation_list)",
                      "to_pixel(self, wcs, origin, mode)",
                      "from_pixel(cls, xp, yp, wcs, origin, mode)",
                      "contained_by(self, wcs, image)",
                      "radial_velocity_correction(self, kind, obstime, location)",
                      "guess_from_table(cls, table)",
                      "from_name(cls, name, frame, parse, cache)"
                    ]
                  }
                ],
                "functions": []
              },
              {
                "file_path": "astropy/units/core.py",
                "module_docstring": "Core units classes and functions",
                "classes": [
                  {
                    "name": "_UnitRegistry()",
                    "docstring": "Manages a registry of the enabled units.",
                    "methods": [
                      "__init__(self, init, equivalencies, aliases)",
                      "_reset_units(self)",
                      "_reset_equivalencies(self)",
                      "_reset_aliases(self)",
                      "registry(self)",
                      "all_units(self)",
                      "non_prefix_units(self)",
                      "set_enabled_units(self, units)",
                      "add_enabled_units(self, units)",
                      "get_units_with_physical_type(self, unit)",
                      "equivalencies(self)",
                      "set_enabled_equivalencies(self, equivalencies)",
                      "add_enabled_equivalencies(self, equivalencies)",
                      "aliases(self)",
                      "set_enabled_aliases(self, aliases)",
                      "add_enabled_aliases(self, aliases)"
                    ]
                  },
                  {
                    "name": "_UnitContext()",
                    "docstring": null,
                    "methods": [
                      "__init__(self, init, equivalencies)",
                      "__enter__(self)",
                      "__exit__(self, type, value, tb)"
                    ]
                  },
                  {
                    "name": "UnitsError(Exception)",
                    "docstring": "The base class for unit-specific exceptions.",
                    "methods": []
                  },
                  {
                    "name": "UnitScaleError(UnitsError, ValueError)",
                    "docstring": "Used to catch the errors involving scaled units,\nwhich are not recognized by FITS format.",
                    "methods": []
                  },
                  {
                    "name": "UnitConversionError(UnitsError, ValueError)",
                    "docstring": "Used specifically for errors related to converting between units or\ninterpreting units in terms of other units.",
                    "methods": []
                  },
                  {
                    "name": "UnitTypeError(UnitsError, TypeError)",
                    "docstring": "Used specifically for errors in setting to units not allowed by a class.\n\nE.g., would be raised if the unit of an `~astropy.coordinates.Angle`\ninstances were set to a non-angular unit.",
                    "methods": []
                  },
                  {
                    "name": "UnitsWarning(AstropyWarning)",
                    "docstring": "The base class for unit-specific warnings.",
                    "methods": []
                  },
                  {
                    "name": "UnitBase()",
                    "docstring": "Abstract base class for units.\n\nMost of the arithmetic operations on units are defined in this\nbase class.\n\nShould not be instantiated by users directly.",
                    "methods": [
                      "__deepcopy__(self, memo)",
                      "_repr_latex_(self)",
                      "__bytes__(self)",
                      "__str__(self)",
                      "__repr__(self)",
                      "_get_physical_type_id(self)",
                      "names(self)",
                      "name(self)",
                      "aliases(self)",
                      "scale(self)",
                      "bases(self)",
                      "powers(self)",
                      "to_string(self, format)",
                      "__format__(self, format_spec)",
                      "_normalize_equivalencies(equivalencies)",
                      "__pow__(self, p)",
                      "__truediv__(self, m)",
                      "__rtruediv__(self, m)",
                      "__mul__(self, m)",
                      "__rmul__(self, m)",
                      "__rlshift__(self, m)",
                      "__rrshift__(self, m)",
                      "__hash__(self)",
                      "__getstate__(self)",
                      "__eq__(self, other)",
                      "__ne__(self, other)",
                      "__le__(self, other)",
                      "__ge__(self, other)",
                      "__lt__(self, other)",
                      "__gt__(self, other)",
                      "__neg__(self)",
                      "is_equivalent(self, other, equivalencies)",
                      "_is_equivalent(self, other, equivalencies)",
                      "_apply_equivalencies(self, unit, other, equivalencies)",
                      "_get_converter(self, other, equivalencies)",
                      "_to(self, other)",
                      "to(self, other, value, equivalencies)",
                      "in_units(self, other, value, equivalencies)",
                      "decompose(self, bases)",
                      "_compose(self, equivalencies, namespace, max_depth, depth, cached_results)",
                      "compose(self, equivalencies, units, max_depth, include_prefix_units)",
                      "to_system(self, system)",
                      "si(self)",
                      "cgs(self)",
                      "physical_type(self)",
                      "_get_units_with_same_physical_type(self, equivalencies)",
                      "find_equivalent_units(self, equivalencies, units, include_prefix_units)",
                      "is_unity(self)"
                    ]
                  },
                  {
                    "name": "NamedUnit(UnitBase)",
                    "docstring": "The base class of units that have a name.\n\nParameters\n----------\nst : str, list of str, 2-tuple\n    The name of the unit.  If a list of strings, the first element\n    is the canonical (short) name, and the rest of the elements\n    are aliases.  If a tuple of lists, the first element is a list\n    of short names, and the second element is a list of long\n    names; all but the first short name are considered \"aliases\".\n    Each name *should* be a valid Python identifier to make it\n    easy to access, but this is not required.\n\nnamespace : dict, optional\n    When provided, inject the unit, and all of its aliases, in the\n    given namespace dictionary.  If a unit by the same name is\n    already in the namespace, a ValueError is raised.\n\ndoc : str, optional\n    A docstring describing the unit.\n\nformat : dict, optional\n    A mapping to format-specific representations of this unit.\n    For example, for the ``Ohm`` unit, it might be nice to have it\n    displayed as ``\\Omega`` by the ``latex`` formatter.  In that\n    case, `format` argument should be set to::\n\n        {'latex': r'\\Omega'}\n\nRaises\n------\nValueError\n    If any of the given unit names are already in the registry.\n\nValueError\n    If any of the given unit names are not valid Python tokens.",
                    "methods": [
                      "__init__(self, st, doc, format, namespace)",
                      "_generate_doc(self)",
                      "get_format_name(self, format)",
                      "names(self)",
                      "name(self)",
                      "aliases(self)",
                      "short_names(self)",
                      "long_names(self)",
                      "_inject(self, namespace)"
                    ]
                  },
                  {
                    "name": "IrreducibleUnit(NamedUnit)",
                    "docstring": "Irreducible units are the units that all other units are defined\nin terms of.\n\nExamples are meters, seconds, kilograms, amperes, etc.  There is\nonly once instance of such a unit per type.",
                    "methods": [
                      "__reduce__(self)",
                      "represents(self)",
                      "decompose(self, bases)"
                    ]
                  },
                  {
                    "name": "UnrecognizedUnit(IrreducibleUnit)",
                    "docstring": "A unit that did not parse correctly.  This allows for\nround-tripping it as a string, but no unit operations actually work\non it.\n\nParameters\n----------\nst : str\n    The name of the unit.",
                    "methods": [
                      "__repr__(self)",
                      "__bytes__(self)",
                      "__str__(self)",
                      "to_string(self, format)",
                      "_unrecognized_operator(self)",
                      "__eq__(self, other)",
                      "__ne__(self, other)",
                      "is_equivalent(self, other, equivalencies)",
                      "_get_converter(self, other, equivalencies)",
                      "get_format_name(self, format)",
                      "is_unity(self)"
                    ]
                  },
                  {
                    "name": "_UnitMetaClass(type)",
                    "docstring": "This metaclass exists because the Unit constructor should\nsometimes return instances that already exist.  This \"overrides\"\nthe constructor before the new instance is actually created, so we\ncan return an existing one.",
                    "methods": [
                      "__call__(self, s, represents, format, namespace, doc, parse_strict)"
                    ]
                  },
                  {
                    "name": "Unit(NamedUnit)",
                    "docstring": "The main unit class.\n\nThere are a number of different ways to construct a Unit, but\nalways returns a `UnitBase` instance.  If the arguments refer to\nan already-existing unit, that existing unit instance is returned,\nrather than a new one.\n\n- From a string::\n\n    Unit(s, format=None, parse_strict='silent')\n\n  Construct from a string representing a (possibly compound) unit.\n\n  The optional `format` keyword argument specifies the format the\n  string is in, by default ``\"generic\"``.  For a description of\n  the available formats, see `astropy.units.format`.\n\n  The optional ``parse_strict`` keyword controls what happens when an\n  unrecognized unit string is passed in.  It may be one of the following:\n\n     - ``'raise'``: (default) raise a ValueError exception.\n\n     - ``'warn'``: emit a Warning, and return an\n       `UnrecognizedUnit` instance.\n\n     - ``'silent'``: return an `UnrecognizedUnit` instance.\n\n- From a number::\n\n    Unit(number)\n\n  Creates a dimensionless unit.\n\n- From a `UnitBase` instance::\n\n    Unit(unit)\n\n  Returns the given unit unchanged.\n\n- From no arguments::\n\n    Unit()\n\n  Returns the dimensionless unit.\n\n- The last form, which creates a new `Unit` is described in detail\n  below.\n\nSee also: https://docs.astropy.org/en/stable/units/\n\nParameters\n----------\nst : str or list of str\n    The name of the unit.  If a list, the first element is the\n    canonical (short) name, and the rest of the elements are\n    aliases.\n\nrepresents : UnitBase instance\n    The unit that this named unit represents.\n\ndoc : str, optional\n    A docstring describing the unit.\n\nformat : dict, optional\n    A mapping to format-specific representations of this unit.\n    For example, for the ``Ohm`` unit, it might be nice to have it\n    displayed as ``\\Omega`` by the ``latex`` formatter.  In that\n    case, `format` argument should be set to::\n\n        {'latex': r'\\Omega'}\n\nnamespace : dict, optional\n    When provided, inject the unit (and all of its aliases) into\n    the given namespace.\n\nRaises\n------\nValueError\n    If any of the given unit names are already in the registry.\n\nValueError\n    If any of the given unit names are not valid Python tokens.",
                    "methods": [
                      "__init__(self, st, represents, doc, format, namespace)",
                      "represents(self)",
                      "decompose(self, bases)",
                      "is_unity(self)",
                      "__hash__(self)",
                      "_from_physical_type_id(cls, physical_type_id)"
                    ]
                  },
                  {
                    "name": "PrefixUnit(Unit)",
                    "docstring": "A unit that is simply a SI-prefixed version of another unit.\n\nFor example, ``mm`` is a `PrefixUnit` of ``.001 * m``.\n\nThe constructor is the same as for `Unit`.",
                    "methods": []
                  },
                  {
                    "name": "CompositeUnit(UnitBase)",
                    "docstring": "Create a composite unit using expressions of previously defined\nunits.\n\nDirect use of this class is not recommended. Instead use the\nfactory function `Unit` and arithmetic operators to compose\nunits.\n\nParameters\n----------\nscale : number\n    A scaling factor for the unit.\n\nbases : sequence of `UnitBase`\n    A sequence of units this unit is composed of.\n\npowers : sequence of numbers\n    A sequence of powers (in parallel with ``bases``) for each\n    of the base units.",
                    "methods": [
                      "__init__(self, scale, bases, powers, decompose, decompose_bases, _error_check)",
                      "__repr__(self)",
                      "scale(self)",
                      "bases(self)",
                      "powers(self)",
                      "_expand_and_gather(self, decompose, bases)",
                      "__copy__(self)",
                      "decompose(self, bases)",
                      "is_unity(self)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "_flatten_units_collection(items)",
                    "content": "def _flatten_units_collection(items):\n    \"\"\"\n    Given a list of sequences, modules or dictionaries of units, or\n    single units, return a flat set of all the units found.\n    \"\"\"\n...\n            for unit in units:\n                if isinstance(unit, UnitBase):\n                    result.add(unit)\n\n    return result"
                  },
                  {
                    "name": "_normalize_equivalencies(equivalencies)",
                    "content": "def _normalize_equivalencies(equivalencies):\n    \"\"\"\n    Normalizes equivalencies, ensuring each is a 4-tuple of the form::\n\n    (from_unit, to_unit, forward_func, backward_func)\n...\n            raise ValueError(\n                f\"Invalid equivalence entry {i}: {equiv!r}\")\n        normalized.append((funit, tunit, a, b))\n\n    return normalized"
                  },
                  {
                    "name": "get_current_unit_registry()",
                    "content": "def get_current_unit_registry():\n    return _unit_registries[-1]"
                  },
                  {
                    "name": "set_enabled_units(units)",
                    "content": "def set_enabled_units(units):\n    \"\"\"\n    Sets the units enabled in the unit registry.\n\n    These units are searched when using\n...\n    context = _UnitContext(\n        equivalencies=get_current_unit_registry().equivalencies)\n    # in this new current registry, enable the units requested\n    get_current_unit_registry().set_enabled_units(units)\n    return context"
                  },
                  {
                    "name": "add_enabled_units(units)",
                    "content": "def add_enabled_units(units):\n    \"\"\"\n    Adds to the set of units enabled in the unit registry.\n\n    These units are searched when using\n...\n    # get a context with a new registry, which is a copy of the current one\n    context = _UnitContext(get_current_unit_registry())\n    # in this new current registry, enable the further units requested\n    get_current_unit_registry().add_enabled_units(units)\n    return context"
                  },
                  {
                    "name": "set_enabled_equivalencies(equivalencies)",
                    "content": "def set_enabled_equivalencies(equivalencies):\n    \"\"\"\n    Sets the equivalencies enabled in the unit registry.\n\n    These equivalencies are used if no explicit equivalencies are given,\n...\n    # get a context with a new registry, using all units of the current one\n    context = _UnitContext(get_current_unit_registry())\n    # in this new current registry, enable the equivalencies requested\n    get_current_unit_registry().set_enabled_equivalencies(equivalencies)\n    return context"
                  },
                  {
                    "name": "add_enabled_equivalencies(equivalencies)",
                    "content": "def add_enabled_equivalencies(equivalencies):\n    \"\"\"\n    Adds to the equivalencies enabled in the unit registry.\n\n    These equivalencies are used if no explicit equivalencies are given,\n...\n    # get a context with a new registry, which is a copy of the current one\n    context = _UnitContext(get_current_unit_registry())\n    # in this new current registry, enable the further equivalencies requested\n    get_current_unit_registry().add_enabled_equivalencies(equivalencies)\n    return context"
                  },
                  {
                    "name": "set_enabled_aliases(aliases)",
                    "content": "def set_enabled_aliases(aliases):\n    \"\"\"\n    Set aliases for units.\n\n    This is useful for handling alternate spellings for units, or\n...\n    # get a context with a new registry, which is a copy of the current one\n    context = _UnitContext(get_current_unit_registry())\n    # in this new current registry, enable the further equivalencies requested\n    get_current_unit_registry().set_enabled_aliases(aliases)\n    return context"
                  },
                  {
                    "name": "add_enabled_aliases(aliases)",
                    "content": "def add_enabled_aliases(aliases):\n    \"\"\"\n    Add aliases for units.\n\n    This is useful for handling alternate spellings for units, or\n...\n    # get a context with a new registry, which is a copy of the current one\n    context = _UnitContext(get_current_unit_registry())\n    # in this new current registry, enable the further equivalencies requested\n    get_current_unit_registry().add_enabled_aliases(aliases)\n    return context"
                  },
                  {
                    "name": "_recreate_irreducible_unit(cls, names, registered)",
                    "content": "def _recreate_irreducible_unit(cls, names, registered):\n    \"\"\"\n    This is used to reconstruct units when passed around by\n    multiprocessing.\n    \"\"\"\n...\n            # If not in local registry but registered in origin registry,\n            # enable unit in local registry.\n            get_current_unit_registry().add_enabled_units([unit])\n\n        return unit"
                  },
                  {
                    "name": "_add_prefixes(u, excludes, namespace, prefixes)",
                    "content": "def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):\n    \"\"\"\n    Set up all of the standard metric prefixes for a unit.  This\n    function should not be used directly, but instead use the\n    `prefixes` kwarg on `def_unit`.\n...\n\n        if len(names):\n            PrefixUnit(names, CompositeUnit(factor, [u], [1],\n                                            _error_check=False),\n                       namespace=namespace, format=format)"
                  },
                  {
                    "name": "def_unit(s, represents, doc, format, prefixes, exclude_prefixes, namespace)",
                    "content": "def def_unit(s, represents=None, doc=None, format=None, prefixes=False,\n             exclude_prefixes=[], namespace=None):\n    \"\"\"\n    Factory function for defining new units.\n\n...\n\n    if prefixes:\n        _add_prefixes(result, excludes=exclude_prefixes, namespace=namespace,\n                      prefixes=prefixes)\n    return result"
                  },
                  {
                    "name": "_condition_arg(value)",
                    "content": "def _condition_arg(value):\n    \"\"\"\n    Validate value is acceptable for conversion purposes.\n\n    Will convert into an array if not a scalar, and can be converted\n...\n    avalue = np.array(value)\n    if avalue.dtype.kind not in ['i', 'f', 'c']:\n        raise ValueError(\"Value not scalar compatible or convertible to \"\n                         \"an int, float, or complex array\")\n    return avalue"
                  },
                  {
                    "name": "unit_scale_converter(val)",
                    "content": "def unit_scale_converter(val):\n    \"\"\"Function that just multiplies the value by unity.\n\n    This is a separate function so it can be recognized and\n    discarded in unit conversion.\n    \"\"\"\n    return 1. * _condition_arg(val)"
                  }
                ]
              },
              {
                "file_path": "astropy/io/fits/hdu/table.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "FITSTableDumpDialect(csv.excel)",
                    "docstring": "A CSV dialect for the Astropy format of ASCII dumps of FITS tables.",
                    "methods": []
                  },
                  {
                    "name": "_TableLikeHDU(_ValidHDU)",
                    "docstring": "A class for HDUs that have table-like data.  This is used for both\nBinary/ASCII tables as well as Random Access Group HDUs (which are\notherwise too dissimilar for tables to use _TableBaseHDU directly).",
                    "methods": [
                      "match_header(cls, header)",
                      "from_columns(cls, columns, header, nrows, fill, character_as_bytes)",
                      "columns(self)",
                      "_nrows(self)",
                      "_get_tbdata(self)",
                      "_init_tbdata(self, data)",
                      "_update_load_data(self)",
                      "_update_column_added(self, columns, column)",
                      "_update_column_removed(self, columns, col_idx)"
                    ]
                  },
                  {
                    "name": "_TableBaseHDU(ExtensionHDU, _TableLikeHDU)",
                    "docstring": "FITS table extension base HDU class.\n\nParameters\n----------\ndata : array\n    Data to be used.\nheader : `Header` instance\n    Header to be used. If the ``data`` is also specified, header keywords\n    specifically related to defining the table structure (such as the\n    \"TXXXn\" keywords like TTYPEn) will be overridden by the supplied column\n    definitions, but all other informational and data model-specific\n    keywords are kept.\nname : str\n    Name to be populated in ``EXTNAME`` keyword.\nuint : bool, optional\n    Set to `True` if the table contains unsigned integer columns.\nver : int > 0 or None, optional\n    The ver of the HDU, will be the value of the keyword ``EXTVER``.\n    If not given or None, it defaults to the value of the ``EXTVER``\n    card of the ``header`` or 1.\n    (default: None)\ncharacter_as_bytes : bool\n    Whether to return bytes for string columns. By default this is `False`\n    and (unicode) strings are returned, but this does not respect memory\n    mapping and loads the whole column in memory when accessed.",
                    "methods": [
                      "__init__(self, data, header, name, uint, ver, character_as_bytes)",
                      "match_header(cls, header)",
                      "columns(self)",
                      "data(self)",
                      "data(self, data)",
                      "_nrows(self)",
                      "_theap(self)",
                      "update(self)",
                      "copy(self)",
                      "_prewriteto(self, checksum, inplace)",
                      "_verify(self, option)",
                      "_summary(self)",
                      "_update_column_removed(self, columns, idx)",
                      "_update_column_attribute_changed(self, column, col_idx, attr, old_value, new_value)",
                      "_clear_table_keywords(self, index)",
                      "_populate_table_keywords(self)"
                    ]
                  },
                  {
                    "name": "TableHDU(_TableBaseHDU)",
                    "docstring": "FITS ASCII table extension HDU class.\n\nParameters\n----------\ndata : array or `FITS_rec`\n    Data to be used.\nheader : `Header`\n    Header to be used.\nname : str\n    Name to be populated in ``EXTNAME`` keyword.\nver : int > 0 or None, optional\n    The ver of the HDU, will be the value of the keyword ``EXTVER``.\n    If not given or None, it defaults to the value of the ``EXTVER``\n    card of the ``header`` or 1.\n    (default: None)\ncharacter_as_bytes : bool\n    Whether to return bytes for string columns. By default this is `False`\n    and (unicode) strings are returned, but this does not respect memory\n    mapping and loads the whole column in memory when accessed.",
                    "methods": [
                      "__init__(self, data, header, name, ver, character_as_bytes)",
                      "match_header(cls, header)",
                      "_get_tbdata(self)",
                      "_calculate_datasum(self)",
                      "_verify(self, option)"
                    ]
                  },
                  {
                    "name": "BinTableHDU(_TableBaseHDU)",
                    "docstring": "Binary table HDU class.\n\nParameters\n----------\ndata : array, `FITS_rec`, or `~astropy.table.Table`\n    Data to be used.\nheader : `Header`\n    Header to be used.\nname : str\n    Name to be populated in ``EXTNAME`` keyword.\nuint : bool, optional\n    Set to `True` if the table contains unsigned integer columns.\nver : int > 0 or None, optional\n    The ver of the HDU, will be the value of the keyword ``EXTVER``.\n    If not given or None, it defaults to the value of the ``EXTVER``\n    card of the ``header`` or 1.\n    (default: None)\ncharacter_as_bytes : bool\n    Whether to return bytes for string columns. By default this is `False`\n    and (unicode) strings are returned, but this does not respect memory\n    mapping and loads the whole column in memory when accessed.",
                    "methods": [
                      "__init__(self, data, header, name, uint, ver, character_as_bytes)",
                      "match_header(cls, header)",
                      "_calculate_datasum_with_heap(self)",
                      "_calculate_datasum(self)",
                      "_writedata_internal(self, fileobj)",
                      "_writedata_by_row(self, fileobj)",
                      "dump(self, datafile, cdfile, hfile, overwrite)",
                      "load(cls, datafile, cdfile, hfile, replace, header)",
                      "_dump_data(self, fileobj)",
                      "_dump_coldefs(self, fileobj)",
                      "_load_data(cls, fileobj, coldefs)",
                      "_load_coldefs(cls, fileobj)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "_binary_table_byte_swap(data)",
                    "content": "def _binary_table_byte_swap(data):\n    \"\"\"\n    Ensures that all the data of a binary FITS table (represented as a FITS_rec\n    object) is in a big-endian byte order.  Columns are swapped in-place one\n    at a time, and then returned to their previous byte order when this context\n...\n\n    for arr in to_swap:\n        arr.byteswap(True)\n\n    data.dtype = orig_dtype"
                  }
                ]
              },
              {
                "file_path": "astropy/modeling/polynomial.py",
                "module_docstring": "This module contains models representing polynomials and polynomial series.",
                "classes": [
                  {
                    "name": "PolynomialBase(FittableModel)",
                    "docstring": "Base class for all polynomial-like models with an arbitrary number of\nparameters in the form of coefficients.\n\nIn this case Parameter instances are returned through the class's\n``__getattr__`` rather than through class descriptors.",
                    "methods": [
                      "param_names(self)"
                    ]
                  },
                  {
                    "name": "PolynomialModel(PolynomialBase)",
                    "docstring": "Base class for polynomial models.\n\nIts main purpose is to determine how many coefficients are needed\nbased on the polynomial order and dimension and to provide their\ndefault values, names and ordering.",
                    "methods": [
                      "__init__(self, degree, n_models, model_set_axis, name, meta)",
                      "degree(self)",
                      "get_num_coeff(self, ndim)",
                      "_invlex(self)",
                      "_generate_coeff_names(self, ndim)"
                    ]
                  },
                  {
                    "name": "_PolyDomainWindow1D(PolynomialModel)",
                    "docstring": "This class sets ``domain`` and ``window`` of 1D polynomials.",
                    "methods": [
                      "__init__(self, degree, domain, window, n_models, model_set_axis, name, meta)",
                      "window(self)",
                      "window(self, val)",
                      "domain(self)",
                      "domain(self, val)",
                      "_set_default_domain_window(self, domain, window)",
                      "__repr__(self)",
                      "__str__(self)"
                    ]
                  },
                  {
                    "name": "OrthoPolynomialBase(PolynomialBase)",
                    "docstring": "This is a base class for the 2D Chebyshev and Legendre models.\n\nThe polynomials implemented here require a maximum degree in x and y.\n\nFor explanation of ``x_domain``, ``y_domain``, ```x_window`` and ```y_window``\nsee :ref:`Notes regarding usage of domain and window <astropy:domain-window-note>`.\n\n\nParameters\n----------\n\nx_degree : int\n    degree in x\ny_degree : int\n    degree in y\nx_domain : tuple or None, optional\n    domain of the x independent variable\nx_window : tuple or None, optional\n    range of the x independent variable\ny_domain : tuple or None, optional\n    domain of the y independent variable\ny_window : tuple or None, optional\n    range of the y independent variable\n**params : dict\n    {keyword: value} pairs, representing {parameter_name: value}",
                    "methods": [
                      "__init__(self, x_degree, y_degree, x_domain, x_window, y_domain, y_window, n_models, model_set_axis, name, meta)",
                      "x_domain(self)",
                      "x_domain(self, val)",
                      "y_domain(self)",
                      "y_domain(self, val)",
                      "x_window(self)",
                      "x_window(self, val)",
                      "y_window(self)",
                      "y_window(self, val)",
                      "__repr__(self)",
                      "__str__(self)",
                      "get_num_coeff(self)",
                      "_invlex(self)",
                      "invlex_coeff(self, coeffs)",
                      "_alpha(self)",
                      "imhorner(self, x, y, coeff)",
                      "_generate_coeff_names(self)",
                      "_fcache(self, x, y)",
                      "evaluate(self, x, y)",
                      "prepare_inputs(self, x, y)"
                    ]
                  },
                  {
                    "name": "Chebyshev1D(_PolyDomainWindow1D)",
                    "docstring": "Univariate Chebyshev series.\n\nIt is defined as:\n\n.. math::\n\n    P(x) = \\sum_{i=0}^{i=n}C_{i} * T_{i}(x)\n\nwhere ``T_i(x)`` is the corresponding Chebyshev polynomial of the 1st kind.\n\nFor explanation of ```domain``, and ``window`` see\n:ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\ndegree : int\n    degree of the series\ndomain : tuple or None, optional\nwindow : tuple or None, optional\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window.\n**params : dict\n    keyword : value pairs, representing parameter_name: value\n\nNotes\n-----\n\nThis model does not support the use of units/quantities, because each term\nin the sum of Chebyshev polynomials is a polynomial in x - since the\ncoefficients within each Chebyshev polynomial are fixed, we can't use\nquantities for x since the units would not be compatible. For example, the\nthird Chebyshev polynomial (T2) is 2x^2-1, but if x was specified with\nunits, 2x^2 and -1 would have incompatible units.",
                    "methods": [
                      "__init__(self, degree, domain, window, n_models, model_set_axis, name, meta)",
                      "fit_deriv(self, x)",
                      "prepare_inputs(self, x)",
                      "evaluate(self, x)",
                      "clenshaw(x, coeffs)"
                    ]
                  },
                  {
                    "name": "Hermite1D(_PolyDomainWindow1D)",
                    "docstring": "Univariate Hermite series.\n\nIt is defined as:\n\n.. math::\n\n    P(x) = \\sum_{i=0}^{i=n}C_{i} * H_{i}(x)\n\nwhere ``H_i(x)`` is the corresponding Hermite polynomial (\"Physicist's kind\").\n\nFor explanation of ``domain``, and ``window`` see\n:ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\ndegree : int\n    degree of the series\ndomain : tuple or None, optional\nwindow : tuple or None, optional\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\n**params : dict\n    keyword : value pairs, representing parameter_name: value\n\nNotes\n-----\n\nThis model does not support the use of units/quantities, because each term\nin the sum of Hermite polynomials is a polynomial in x - since the\ncoefficients within each Hermite polynomial are fixed, we can't use\nquantities for x since the units would not be compatible. For example, the\nthird Hermite polynomial (H2) is 4x^2-2, but if x was specified with units,\n4x^2 and -2 would have incompatible units.",
                    "methods": [
                      "__init__(self, degree, domain, window, n_models, model_set_axis, name, meta)",
                      "fit_deriv(self, x)",
                      "prepare_inputs(self, x)",
                      "evaluate(self, x)",
                      "clenshaw(x, coeffs)"
                    ]
                  },
                  {
                    "name": "Hermite2D(OrthoPolynomialBase)",
                    "docstring": "Bivariate Hermite series.\n\nIt is defined as\n\n.. math:: P_{nm}(x,y) = \\sum_{n,m=0}^{n=d,m=d}C_{nm} H_n(x) H_m(y)\n\nwhere ``H_n(x)`` and ``H_m(y)`` are Hermite polynomials.\n\nFor explanation of ``x_domain``, ``y_domain``, ``x_window`` and ``y_window``\nsee :ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\n\nx_degree : int\n    degree in x\ny_degree : int\n    degree in y\nx_domain : tuple or None, optional\n    domain of the x independent variable\ny_domain : tuple or None, optional\n    domain of the y independent variable\nx_window : tuple or None, optional\n    range of the x independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\ny_window : tuple or None, optional\n    range of the y independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\n**params : dict\n    keyword: value pairs, representing parameter_name: value\n\nNotes\n-----\n\nThis model does not support the use of units/quantities, because each term\nin the sum of Hermite polynomials is a polynomial in x and/or y - since the\ncoefficients within each Hermite polynomial are fixed, we can't use\nquantities for x and/or y since the units would not be compatible. For\nexample, the third Hermite polynomial (H2) is 4x^2-2, but if x was\nspecified with units, 4x^2 and -2 would have incompatible units.",
                    "methods": [
                      "__init__(self, x_degree, y_degree, x_domain, x_window, y_domain, y_window, n_models, model_set_axis, name, meta)",
                      "_fcache(self, x, y)",
                      "fit_deriv(self, x, y)",
                      "_hermderiv1d(self, x, deg)"
                    ]
                  },
                  {
                    "name": "Legendre1D(_PolyDomainWindow1D)",
                    "docstring": "Univariate Legendre series.\n\nIt is defined as:\n\n.. math::\n\n    P(x) = \\sum_{i=0}^{i=n}C_{i} * L_{i}(x)\n\nwhere ``L_i(x)`` is the corresponding Legendre polynomial.\n\nFor explanation of ``domain``, and ``window`` see\n:ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\ndegree : int\n    degree of the series\ndomain : tuple or None, optional\nwindow : tuple or None, optional\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\n**params : dict\n    keyword: value pairs, representing parameter_name: value\n\n\nNotes\n-----\n\nThis model does not support the use of units/quantities, because each term\nin the sum of Legendre polynomials is a polynomial in x - since the\ncoefficients within each Legendre polynomial are fixed, we can't use\nquantities for x since the units would not be compatible. For example, the\nthird Legendre polynomial (P2) is 1.5x^2-0.5, but if x was specified with\nunits, 1.5x^2 and -0.5 would have incompatible units.",
                    "methods": [
                      "__init__(self, degree, domain, window, n_models, model_set_axis, name, meta)",
                      "prepare_inputs(self, x)",
                      "evaluate(self, x)",
                      "fit_deriv(self, x)",
                      "clenshaw(x, coeffs)"
                    ]
                  },
                  {
                    "name": "Polynomial1D(_PolyDomainWindow1D)",
                    "docstring": "1D Polynomial model.\n\nIt is defined as:\n\n.. math::\n\n    P = \\sum_{i=0}^{i=n}C_{i} * x^{i}\n\nFor explanation of ``domain``, and ``window`` see\n:ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\ndegree : int\n    degree of the series\ndomain : tuple or None, optional\n    If None, it is set to (-1, 1)\nwindow : tuple or None, optional\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\n**params : dict\n    keyword: value pairs, representing parameter_name: value",
                    "methods": [
                      "__init__(self, degree, domain, window, n_models, model_set_axis, name, meta)",
                      "prepare_inputs(self, x)",
                      "evaluate(self, x)",
                      "fit_deriv(self, x)",
                      "horner(x, coeffs)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Polynomial2D(PolynomialModel)",
                    "docstring": "2D Polynomial  model.\n\nRepresents a general polynomial of degree n:\n\n.. math::\n\n    P(x,y) = c_{00} + c_{10}x + ...+ c_{n0}x^n + c_{01}y + ...+ c_{0n}y^n\n    + c_{11}xy + c_{12}xy^2 + ... + c_{1(n-1)}xy^{n-1}+ ... + c_{(n-1)1}x^{n-1}y\n\nFor explanation of ``x_domain``, ``y_domain``, ``x_window`` and ``y_window``\nsee :ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\ndegree : int\n    Polynomial degree: largest sum of exponents (:math:`i + j`) of\n    variables in each monomial term of the form :math:`x^i y^j`. The\n    number of terms in a 2D polynomial of degree ``n`` is given by binomial\n    coefficient :math:`C(n + 2, 2) = (n + 2)! / (2!\\,n!) = (n + 1)(n + 2) / 2`.\nx_domain : tuple or None, optional\n    domain of the x independent variable\n    If None, it is set to (-1, 1)\ny_domain : tuple or None, optional\n    domain of the y independent variable\n    If None, it is set to (-1, 1)\nx_window : tuple or None, optional\n    range of the x independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the x_domain to x_window\ny_window : tuple or None, optional\n    range of the y independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the y_domain to y_window\n**params : dict\n    keyword: value pairs, representing parameter_name: value",
                    "methods": [
                      "__init__(self, degree, x_domain, y_domain, x_window, y_window, n_models, model_set_axis, name, meta)",
                      "prepare_inputs(self, x, y)",
                      "evaluate(self, x, y)",
                      "__repr__(self)",
                      "__str__(self)",
                      "fit_deriv(self, x, y)",
                      "invlex_coeff(self, coeffs)",
                      "multivariate_horner(self, x, y, coeffs)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)",
                      "x_domain(self)",
                      "x_domain(self, val)",
                      "y_domain(self)",
                      "y_domain(self, val)",
                      "x_window(self)",
                      "x_window(self, val)",
                      "y_window(self)",
                      "y_window(self, val)"
                    ]
                  },
                  {
                    "name": "Chebyshev2D(OrthoPolynomialBase)",
                    "docstring": "Bivariate Chebyshev series..\n\nIt is defined as\n\n.. math:: P_{nm}(x,y) = \\sum_{n,m=0}^{n=d,m=d}C_{nm}  T_n(x ) T_m(y)\n\nwhere ``T_n(x)`` and ``T_m(y)`` are Chebyshev polynomials of the first kind.\n\nFor explanation of ``x_domain``, ``y_domain``, ``x_window`` and ``y_window``\nsee :ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\n\nx_degree : int\n    degree in x\ny_degree : int\n    degree in y\nx_domain : tuple or None, optional\n    domain of the x independent variable\ny_domain : tuple or None, optional\n    domain of the y independent variable\nx_window : tuple or None, optional\n    range of the x independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\ny_window : tuple or None, optional\n    range of the y independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\n\n**params : dict\n    keyword: value pairs, representing parameter_name: value\n\nNotes\n-----\n\nThis model does not support the use of units/quantities, because each term\nin the sum of Chebyshev polynomials is a polynomial in x and/or y - since\nthe coefficients within each Chebyshev polynomial are fixed, we can't use\nquantities for x and/or y since the units would not be compatible. For\nexample, the third Chebyshev polynomial (T2) is 2x^2-1, but if x was\nspecified with units, 2x^2 and -1 would have incompatible units.",
                    "methods": [
                      "__init__(self, x_degree, y_degree, x_domain, x_window, y_domain, y_window, n_models, model_set_axis, name, meta)",
                      "_fcache(self, x, y)",
                      "fit_deriv(self, x, y)",
                      "_chebderiv1d(self, x, deg)"
                    ]
                  },
                  {
                    "name": "Legendre2D(OrthoPolynomialBase)",
                    "docstring": "Bivariate Legendre series.\n\nDefined as:\n\n.. math:: P_{n_m}(x,y) = \\sum_{n,m=0}^{n=d,m=d}C_{nm}  L_n(x ) L_m(y)\n\nwhere ``L_n(x)`` and ``L_m(y)`` are Legendre polynomials.\n\nFor explanation of ``x_domain``, ``y_domain``, ``x_window`` and ``y_window``\nsee :ref:`Notes regarding usage of domain and window <domain-window-note>`.\n\nParameters\n----------\n\nx_degree : int\n    degree in x\ny_degree : int\n    degree in y\nx_domain : tuple or None, optional\n    domain of the x independent variable\ny_domain : tuple or None, optional\n    domain of the y independent variable\nx_window : tuple or None, optional\n    range of the x independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\ny_window : tuple or None, optional\n    range of the y independent variable\n    If None, it is set to (-1, 1)\n    Fitters will remap the domain to this window\n**params : dict\n    keyword: value pairs, representing parameter_name: value\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    P(x) = \\sum_{i=0}^{i=n}C_{i} * L_{i}(x)\n\nwhere ``L_{i}`` is the corresponding Legendre polynomial.\n\nThis model does not support the use of units/quantities, because each term\nin the sum of Legendre polynomials is a polynomial in x - since the\ncoefficients within each Legendre polynomial are fixed, we can't use\nquantities for x since the units would not be compatible. For example, the\nthird Legendre polynomial (P2) is 1.5x^2-0.5, but if x was specified with\nunits, 1.5x^2 and -0.5 would have incompatible units.",
                    "methods": [
                      "__init__(self, x_degree, y_degree, x_domain, x_window, y_domain, y_window, n_models, model_set_axis, name, meta)",
                      "_fcache(self, x, y)",
                      "fit_deriv(self, x, y)",
                      "_legendderiv1d(self, x, deg)"
                    ]
                  },
                  {
                    "name": "_SIP1D(PolynomialBase)",
                    "docstring": "This implements the Simple Imaging Polynomial Model (SIP) in 1D.\n\nIt's unlikely it will be used in 1D so this class is private\nand SIP should be used instead.",
                    "methods": [
                      "__init__(self, order, coeff_prefix, n_models, model_set_axis, name, meta)",
                      "__repr__(self)",
                      "__str__(self)",
                      "evaluate(self, x, y)",
                      "get_num_coeff(self, ndim)",
                      "_generate_coeff_names(self, coeff_prefix)",
                      "_coeff_matrix(self, coeff_prefix, coeffs)",
                      "_eval_sip(self, x, y, coef)"
                    ]
                  },
                  {
                    "name": "SIP(Model)",
                    "docstring": "Simple Imaging Polynomial (SIP) model.\n\nThe SIP convention is used to represent distortions in FITS image headers.\nSee [1]_ for a description of the SIP convention.\n\nParameters\n----------\ncrpix : list or (2,) ndarray\n    CRPIX values\na_order : int\n    SIP polynomial order for first axis\nb_order : int\n    SIP order for second axis\na_coeff : dict\n    SIP coefficients for first axis\nb_coeff : dict\n    SIP coefficients for the second axis\nap_order : int\n    order for the inverse transformation (AP coefficients)\nbp_order : int\n    order for the inverse transformation (BP coefficients)\nap_coeff : dict\n    coefficients for the inverse transform\nbp_coeff : dict\n    coefficients for the inverse transform\n\nReferences\n----------\n.. [1] `David Shupe, et al, ADASS, ASP Conference Series, Vol. 347, 2005 <https://ui.adsabs.harvard.edu/abs/2005ASPC..347..491S>`_",
                    "methods": [
                      "__init__(self, crpix, a_order, b_order, a_coeff, b_coeff, ap_order, bp_order, ap_coeff, bp_coeff, n_models, model_set_axis, name, meta)",
                      "__repr__(self)",
                      "__str__(self)",
                      "inverse(self)",
                      "evaluate(self, x, y)"
                    ]
                  },
                  {
                    "name": "InverseSIP(Model)",
                    "docstring": "Inverse Simple Imaging Polynomial\n\nParameters\n----------\nap_order : int\n    order for the inverse transformation (AP coefficients)\nbp_order : int\n    order for the inverse transformation (BP coefficients)\nap_coeff : dict\n    coefficients for the inverse transform\nbp_coeff : dict\n    coefficients for the inverse transform",
                    "methods": [
                      "__init__(self, ap_order, bp_order, ap_coeff, bp_coeff, n_models, model_set_axis, name, meta)",
                      "__repr__(self)",
                      "__str__(self)",
                      "evaluate(self, x, y)"
                    ]
                  }
                ],
                "functions": []
              },
              {
                "file_path": "astropy/modeling/functional_models.py",
                "module_docstring": "Mathematical models.",
                "classes": [
                  {
                    "name": "Gaussian1D(Fittable1DModel)",
                    "docstring": "One dimensional Gaussian model.\n\nParameters\n----------\namplitude : float or `~astropy.units.Quantity`.\n    Amplitude (peak value) of the Gaussian - for a normalized profile\n    (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\nmean : float or `~astropy.units.Quantity`.\n    Mean of the Gaussian.\nstddev : float or `~astropy.units.Quantity`.\n    Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n\nNotes\n-----\nEither all or none of input ``x``, ``mean`` and ``stddev`` must be provided\nconsistently with compatible units or as unitless numbers.\n\nModel formula:\n\n    .. math:: f(x) = A e^{- \\frac{\\left(x - x_{0}\\right)^{2}}{2 \\sigma^{2}}}\n\nExamples\n--------\n>>> from astropy.modeling import models\n>>> def tie_center(model):\n...         mean = 50 * model.stddev\n...         return mean\n>>> tied_parameters = {'mean': tie_center}\n\nSpecify that 'mean' is a tied parameter in one of two ways:\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\n...                             tied=tied_parameters)\n\nor\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\n>>> g1.mean.tied\nFalse\n>>> g1.mean.tied = tie_center\n>>> g1.mean.tied\n<function tie_center at 0x...>\n\nFixed parameters:\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,\n...                        fixed={'stddev': True})\n>>> g1.stddev.fixed\nTrue\n\nor\n\n>>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)\n>>> g1.stddev.fixed\nFalse\n>>> g1.stddev.fixed = True\n>>> g1.stddev.fixed\nTrue\n\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Gaussian1D\n\n    plt.figure()\n    s1 = Gaussian1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -1, 4])\n    plt.show()\n\nSee Also\n--------\nGaussian2D, Box1D, Moffat1D, Lorentz1D",
                    "methods": [
                      "bounding_box(self, factor)",
                      "fwhm(self)",
                      "evaluate(x, amplitude, mean, stddev)",
                      "fit_deriv(x, amplitude, mean, stddev)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Gaussian2D(Fittable2DModel)",
                    "docstring": "Two dimensional Gaussian model.\n\nParameters\n----------\namplitude : float or `~astropy.units.Quantity`.\n    Amplitude (peak value) of the Gaussian.\nx_mean : float or `~astropy.units.Quantity`.\n    Mean of the Gaussian in x.\ny_mean : float or `~astropy.units.Quantity`.\n    Mean of the Gaussian in y.\nx_stddev : float or `~astropy.units.Quantity` or None.\n    Standard deviation of the Gaussian in x before rotating by theta. Must\n    be None if a covariance matrix (``cov_matrix``) is provided. If no\n    ``cov_matrix`` is given, ``None`` means the default value (1).\ny_stddev : float or `~astropy.units.Quantity` or None.\n    Standard deviation of the Gaussian in y before rotating by theta. Must\n    be None if a covariance matrix (``cov_matrix``) is provided. If no\n    ``cov_matrix`` is given, ``None`` means the default value (1).\ntheta : float or `~astropy.units.Quantity`, optional.\n    Rotation angle (value in radians). The rotation angle increases\n    counterclockwise.  Must be None if a covariance matrix (``cov_matrix``)\n    is provided. If no ``cov_matrix`` is given, ``None`` means the default\n    value (0).\ncov_matrix : ndarray, optional\n    A 2x2 covariance matrix. If specified, overrides the ``x_stddev``,\n    ``y_stddev``, and ``theta`` defaults.\n\nNotes\n-----\nEither all or none of input ``x, y``, ``[x,y]_mean`` and ``[x,y]_stddev``\nmust be provided consistently with compatible units or as unitless numbers.\n\nModel formula:\n\n    .. math::\n\n        f(x, y) = A e^{-a\\left(x - x_{0}\\right)^{2}  -b\\left(x - x_{0}\\right)\n        \\left(y - y_{0}\\right)  -c\\left(y - y_{0}\\right)^{2}}\n\nUsing the following definitions:\n\n    .. math::\n        a = \\left(\\frac{\\cos^{2}{\\left (\\theta \\right )}}{2 \\sigma_{x}^{2}} +\n        \\frac{\\sin^{2}{\\left (\\theta \\right )}}{2 \\sigma_{y}^{2}}\\right)\n\n        b = \\left(\\frac{\\sin{\\left (2 \\theta \\right )}}{2 \\sigma_{x}^{2}} -\n        \\frac{\\sin{\\left (2 \\theta \\right )}}{2 \\sigma_{y}^{2}}\\right)\n\n        c = \\left(\\frac{\\sin^{2}{\\left (\\theta \\right )}}{2 \\sigma_{x}^{2}} +\n        \\frac{\\cos^{2}{\\left (\\theta \\right )}}{2 \\sigma_{y}^{2}}\\right)\n\nIf using a ``cov_matrix``, the model is of the form:\n    .. math::\n        f(x, y) = A e^{-0.5 \\left(\\vec{x} - \\vec{x}_{0}\\right)^{T} \\Sigma^{-1} \\left(\\vec{x} - \\vec{x}_{0}\\right)}\n\nwhere :math:`\\vec{x} = [x, y]`, :math:`\\vec{x}_{0} = [x_{0}, y_{0}]`,\nand :math:`\\Sigma` is the covariance matrix:\n\n    .. math::\n        \\Sigma = \\left(\\begin{array}{ccc}\n        \\sigma_x^2               & \\rho \\sigma_x \\sigma_y \\\\\n        \\rho \\sigma_x \\sigma_y   & \\sigma_y^2\n        \\end{array}\\right)\n\n:math:`\\rho` is the correlation between ``x`` and ``y``, which should\nbe between -1 and +1.  Positive correlation corresponds to a\n``theta`` in the range 0 to 90 degrees.  Negative correlation\ncorresponds to a ``theta`` in the range of 0 to -90 degrees.\n\nSee [1]_ for more details about the 2D Gaussian function.\n\nSee Also\n--------\nGaussian1D, Box2D, Moffat2D\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Gaussian_function",
                    "methods": [
                      "__init__(self, amplitude, x_mean, y_mean, x_stddev, y_stddev, theta, cov_matrix)",
                      "x_fwhm(self)",
                      "y_fwhm(self)",
                      "bounding_box(self, factor)",
                      "evaluate(x, y, amplitude, x_mean, y_mean, x_stddev, y_stddev, theta)",
                      "fit_deriv(x, y, amplitude, x_mean, y_mean, x_stddev, y_stddev, theta)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Shift(Fittable1DModel)",
                    "docstring": "Shift a coordinate.\n\nParameters\n----------\noffset : float\n    Offset to add to a coordinate.",
                    "methods": [
                      "input_units(self)",
                      "inverse(self)",
                      "evaluate(x, offset)",
                      "sum_of_implicit_terms(x)",
                      "fit_deriv(x)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Scale(Fittable1DModel)",
                    "docstring": "Multiply a model by a dimensionless factor.\n\nParameters\n----------\nfactor : float\n    Factor by which to scale a coordinate.\n\nNotes\n-----\n\nIf ``factor`` is a `~astropy.units.Quantity` then the units will be\nstripped before the scaling operation.",
                    "methods": [
                      "input_units(self)",
                      "inverse(self)",
                      "evaluate(x, factor)",
                      "fit_deriv(x)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Multiply(Fittable1DModel)",
                    "docstring": "Multiply a model by a quantity or number.\n\nParameters\n----------\nfactor : float\n    Factor by which to multiply a coordinate.",
                    "methods": [
                      "inverse(self)",
                      "evaluate(x, factor)",
                      "fit_deriv(x)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "RedshiftScaleFactor(Fittable1DModel)",
                    "docstring": "One dimensional redshift scale factor model.\n\nParameters\n----------\nz : float\n    Redshift value.\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = x (1 + z)",
                    "methods": [
                      "evaluate(x, z)",
                      "fit_deriv(x, z)",
                      "inverse(self)"
                    ]
                  },
                  {
                    "name": "Sersic1D(Fittable1DModel)",
                    "docstring": "One dimensional Sersic surface brightness profile.\n\nParameters\n----------\namplitude : float\n    Surface brightness at r_eff.\nr_eff : float\n    Effective (half-light) radius\nn : float\n    Sersic Index.\n\nSee Also\n--------\nGaussian1D, Moffat1D, Lorentz1D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    I(r)=I_e\\exp\\left\\{-b_n\\left[\\left(\\frac{r}{r_{e}}\\right)^{(1/n)}-1\\right]\\right\\}\n\nThe constant :math:`b_n` is defined such that :math:`r_e` contains half the total\nluminosity, and can be solved for numerically.\n\n.. math::\n\n    \\Gamma(2n) = 2\\gamma (b_n,2n)\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    from astropy.modeling.models import Sersic1D\n    import matplotlib.pyplot as plt\n\n    plt.figure()\n    plt.subplot(111, xscale='log', yscale='log')\n    s1 = Sersic1D(amplitude=1, r_eff=5)\n    r=np.arange(0, 100, .01)\n\n    for n in range(1, 10):\n         s1.n = n\n         plt.plot(r, s1(r), color=str(float(n) / 15))\n\n    plt.axis([1e-1, 30, 1e-2, 1e3])\n    plt.xlabel('log Radius')\n    plt.ylabel('log Surface Brightness')\n    plt.text(.25, 1.5, 'n=1')\n    plt.text(.25, 300, 'n=10')\n    plt.xticks([])\n    plt.yticks([])\n    plt.show()\n\nReferences\n----------\n.. [1] http://ned.ipac.caltech.edu/level5/March05/Graham/Graham2.html",
                    "methods": [
                      "evaluate(cls, r, amplitude, r_eff, n)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "_Trigonometric1D(Fittable1DModel)",
                    "docstring": "Base class for one dimensional trigonometric and inverse trigonometric models\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude\nfrequency : float\n    Oscillation frequency\nphase : float\n    Oscillation phase",
                    "methods": [
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Sine1D(_Trigonometric1D)",
                    "docstring": "One dimensional Sine model.\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude\nfrequency : float\n    Oscillation frequency\nphase : float\n    Oscillation phase\n\nSee Also\n--------\nArcSine1D, Cosine1D, Tangent1D, Const1D, Linear1D\n\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = A \\sin(2 \\pi f x + 2 \\pi p)\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Sine1D\n\n    plt.figure()\n    s1 = Sine1D(amplitude=1, frequency=.25)\n    r=np.arange(0, 10, .01)\n\n    for amplitude in range(1,4):\n         s1.amplitude = amplitude\n         plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)\n\n    plt.axis([0, 10, -5, 5])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, frequency, phase)",
                      "fit_deriv(x, amplitude, frequency, phase)",
                      "inverse(self)"
                    ]
                  },
                  {
                    "name": "Cosine1D(_Trigonometric1D)",
                    "docstring": "One dimensional Cosine model.\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude\nfrequency : float\n    Oscillation frequency\nphase : float\n    Oscillation phase\n\nSee Also\n--------\nArcCosine1D, Sine1D, Tangent1D, Const1D, Linear1D\n\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = A \\cos(2 \\pi f x + 2 \\pi p)\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Cosine1D\n\n    plt.figure()\n    s1 = Cosine1D(amplitude=1, frequency=.25)\n    r=np.arange(0, 10, .01)\n\n    for amplitude in range(1,4):\n         s1.amplitude = amplitude\n         plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)\n\n    plt.axis([0, 10, -5, 5])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, frequency, phase)",
                      "fit_deriv(x, amplitude, frequency, phase)",
                      "inverse(self)"
                    ]
                  },
                  {
                    "name": "Tangent1D(_Trigonometric1D)",
                    "docstring": "One dimensional Tangent model.\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude\nfrequency : float\n    Oscillation frequency\nphase : float\n    Oscillation phase\n\nSee Also\n--------\nSine1D, Cosine1D, Const1D, Linear1D\n\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = A \\tan(2 \\pi f x + 2 \\pi p)\n\nNote that the tangent function is undefined for inputs of the form\npi/2 + n*pi for all integers n. Thus thus the default bounding box\nhas been restricted to:\n\n    .. math:: [(-1/4 - p)/f, (1/4 - p)/f]\n\nwhich is the smallest interval for the tangent function to be continuous\non.\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Tangent1D\n\n    plt.figure()\n    s1 = Tangent1D(amplitude=1, frequency=.25)\n    r=np.arange(0, 10, .01)\n\n    for amplitude in range(1,4):\n         s1.amplitude = amplitude\n         plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)\n\n    plt.axis([0, 10, -5, 5])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, frequency, phase)",
                      "fit_deriv(x, amplitude, frequency, phase)",
                      "inverse(self)",
                      "bounding_box(self)"
                    ]
                  },
                  {
                    "name": "_InverseTrigonometric1D(_Trigonometric1D)",
                    "docstring": "Base class for one dimensional inverse trigonometric models",
                    "methods": [
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "ArcSine1D(_InverseTrigonometric1D)",
                    "docstring": "One dimensional ArcSine model returning values between -pi/2 and pi/2\nonly.\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude for corresponding Sine\nfrequency : float\n    Oscillation frequency for corresponding Sine\nphase : float\n    Oscillation phase for corresponding Sine\n\nSee Also\n--------\nSine1D, ArcCosine1D, ArcTangent1D\n\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = ((arcsin(x / A) / 2pi) - p) / f\n\nThe arcsin function being used for this model will only accept inputs\nin [-A, A]; otherwise, a runtime warning will be thrown and the result\nwill be NaN. To avoid this, the bounding_box has been properly set to\naccommodate this; therefore, it is recommended that this model always\nbe evaluated with the ``with_bounding_box=True`` option.\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import ArcSine1D\n\n    plt.figure()\n    s1 = ArcSine1D(amplitude=1, frequency=.25)\n    r=np.arange(-1, 1, .01)\n\n    for amplitude in range(1,4):\n         s1.amplitude = amplitude\n         plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)\n\n    plt.axis([-1, 1, -np.pi/2, np.pi/2])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, frequency, phase)",
                      "fit_deriv(x, amplitude, frequency, phase)",
                      "bounding_box(self)",
                      "inverse(self)"
                    ]
                  },
                  {
                    "name": "ArcCosine1D(_InverseTrigonometric1D)",
                    "docstring": "One dimensional ArcCosine returning values between 0 and pi only.\n\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude for corresponding Cosine\nfrequency : float\n    Oscillation frequency for corresponding Cosine\nphase : float\n    Oscillation phase for corresponding Cosine\n\nSee Also\n--------\nCosine1D, ArcSine1D, ArcTangent1D\n\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = ((arccos(x / A) / 2pi) - p) / f\n\nThe arccos function being used for this model will only accept inputs\nin [-A, A]; otherwise, a runtime warning will be thrown and the result\nwill be NaN. To avoid this, the bounding_box has been properly set to\naccommodate this; therefore, it is recommended that this model always\nbe evaluated with the ``with_bounding_box=True`` option.\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import ArcCosine1D\n\n    plt.figure()\n    s1 = ArcCosine1D(amplitude=1, frequency=.25)\n    r=np.arange(-1, 1, .01)\n\n    for amplitude in range(1,4):\n         s1.amplitude = amplitude\n         plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)\n\n    plt.axis([-1, 1, 0, np.pi])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, frequency, phase)",
                      "fit_deriv(x, amplitude, frequency, phase)",
                      "bounding_box(self)",
                      "inverse(self)"
                    ]
                  },
                  {
                    "name": "ArcTangent1D(_InverseTrigonometric1D)",
                    "docstring": "One dimensional ArcTangent model returning values between -pi/2 and\npi/2 only.\n\nParameters\n----------\namplitude : float\n    Oscillation amplitude for corresponding Tangent\nfrequency : float\n    Oscillation frequency for corresponding Tangent\nphase : float\n    Oscillation phase for corresponding Tangent\n\nSee Also\n--------\nTangent1D, ArcSine1D, ArcCosine1D\n\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = ((arctan(x / A) / 2pi) - p) / f\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import ArcTangent1D\n\n    plt.figure()\n    s1 = ArcTangent1D(amplitude=1, frequency=.25)\n    r=np.arange(-10, 10, .01)\n\n    for amplitude in range(1,4):\n         s1.amplitude = amplitude\n         plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)\n\n    plt.axis([-10, 10, -np.pi/2, np.pi/2])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, frequency, phase)",
                      "fit_deriv(x, amplitude, frequency, phase)",
                      "inverse(self)"
                    ]
                  },
                  {
                    "name": "Linear1D(Fittable1DModel)",
                    "docstring": "One dimensional Line model.\n\nParameters\n----------\nslope : float\n    Slope of the straight line\n\nintercept : float\n    Intercept of the straight line\n\nSee Also\n--------\nConst1D\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = a x + b",
                    "methods": [
                      "evaluate(x, slope, intercept)",
                      "fit_deriv(x)",
                      "inverse(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Planar2D(Fittable2DModel)",
                    "docstring": "Two dimensional Plane model.\n\nParameters\n----------\nslope_x : float\n    Slope of the plane in X\n\nslope_y : float\n    Slope of the plane in Y\n\nintercept : float\n    Z-intercept of the plane\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x, y) = a x + b y + c",
                    "methods": [
                      "evaluate(x, y, slope_x, slope_y, intercept)",
                      "fit_deriv(x, y)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Lorentz1D(Fittable1DModel)",
                    "docstring": "One dimensional Lorentzian model.\n\nParameters\n----------\namplitude : float or `~astropy.units.Quantity`.\n    Peak value - for a normalized profile (integrating to 1),\n    set amplitude = 2 / (np.pi * fwhm)\nx_0 : float or `~astropy.units.Quantity`.\n    Position of the peak\nfwhm : float or `~astropy.units.Quantity`.\n    Full width at half maximum (FWHM)\n\nSee Also\n--------\nGaussian1D, Box1D, RickerWavelet1D\n\nNotes\n-----\nEither all or none of input ``x``, position ``x_0`` and ``fwhm`` must be provided\nconsistently with compatible units or as unitless numbers.\n\nModel formula:\n\n.. math::\n\n    f(x) = \\frac{A \\gamma^{2}}{\\gamma^{2} + \\left(x - x_{0}\\right)^{2}}\n\nwhere :math:`\\gamma` is half of given FWHM.\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Lorentz1D\n\n    plt.figure()\n    s1 = Lorentz1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -1, 4])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, x_0, fwhm)",
                      "fit_deriv(x, amplitude, x_0, fwhm)",
                      "bounding_box(self, factor)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Voigt1D(Fittable1DModel)",
                    "docstring": "One dimensional model for the Voigt profile.\n\nParameters\n----------\nx_0 : float or `~astropy.units.Quantity`\n    Position of the peak\namplitude_L : float or `~astropy.units.Quantity`.\n    The Lorentzian amplitude (peak of the associated Lorentz function)\n    - for a normalized profile (integrating to 1), set\n    amplitude_L = 2 / (np.pi * fwhm_L)\nfwhm_L : float or `~astropy.units.Quantity`\n    The Lorentzian full width at half maximum\nfwhm_G : float or `~astropy.units.Quantity`.\n    The Gaussian full width at half maximum\nmethod : str, optional\n    Algorithm for computing the complex error function; one of\n    'Humlicek2' (default, fast and generally more accurate than ``rtol=3.e-5``) or\n    'Scipy', alternatively 'wofz' (requires ``scipy``, almost as fast and\n    reference in accuracy).\n\nSee Also\n--------\nGaussian1D, Lorentz1D\n\nNotes\n-----\nEither all or none of input ``x``, position ``x_0`` and the ``fwhm_*`` must be provided\nconsistently with compatible units or as unitless numbers.\nVoigt function is calculated as real part of the complex error function computed from either\nHumlicek's rational approximations (JQSRT 21:309, 1979; 27:437, 1982) following\nSchreier 2018 (MNRAS 479, 3068; and ``hum2zpf16m`` from his cpfX.py module); or\n`~scipy.special.wofz` (implementing 'Faddeeva.cc').\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    from astropy.modeling.models import Voigt1D\n    import matplotlib.pyplot as plt\n\n    plt.figure()\n    x = np.arange(0, 10, 0.01)\n    v1 = Voigt1D(x_0=5, amplitude_L=10, fwhm_L=0.5, fwhm_G=0.9)\n    plt.plot(x, v1(x))\n    plt.show()",
                    "methods": [
                      "__init__(self, x_0, amplitude_L, fwhm_L, fwhm_G, method)",
                      "_wrap_wofz(self, z)",
                      "evaluate(self, x, x_0, amplitude_L, fwhm_L, fwhm_G)",
                      "fit_deriv(self, x, x_0, amplitude_L, fwhm_L, fwhm_G)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)",
                      "_hum2zpf16c(z, s)"
                    ]
                  },
                  {
                    "name": "Const1D(Fittable1DModel)",
                    "docstring": "One dimensional Constant model.\n\nParameters\n----------\namplitude : float\n    Value of the constant function\n\nSee Also\n--------\nConst2D\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x) = A\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Const1D\n\n    plt.figure()\n    s1 = Const1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -1, 4])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude)",
                      "fit_deriv(x, amplitude)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Const2D(Fittable2DModel)",
                    "docstring": "Two dimensional Constant model.\n\nParameters\n----------\namplitude : float\n    Value of the constant function\n\nSee Also\n--------\nConst1D\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(x, y) = A",
                    "methods": [
                      "evaluate(x, y, amplitude)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Ellipse2D(Fittable2DModel)",
                    "docstring": "A 2D Ellipse model.\n\nParameters\n----------\namplitude : float\n    Value of the ellipse.\n\nx_0 : float\n    x position of the center of the disk.\n\ny_0 : float\n    y position of the center of the disk.\n\na : float\n    The length of the semimajor axis.\n\nb : float\n    The length of the semiminor axis.\n\ntheta : float\n    The rotation angle in radians of the semimajor axis.  The\n    rotation angle increases counterclockwise from the positive x\n    axis.\n\nSee Also\n--------\nDisk2D, Box2D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    f(x, y) = \\left \\{\n                \\begin{array}{ll}\n                  \\mathrm{amplitude} & : \\left[\\frac{(x - x_0) \\cos\n                    \\theta + (y - y_0) \\sin \\theta}{a}\\right]^2 +\n                    \\left[\\frac{-(x - x_0) \\sin \\theta + (y - y_0)\n                    \\cos \\theta}{b}\\right]^2  \\leq 1 \\\\\n                  0 & : \\mathrm{otherwise}\n                \\end{array}\n              \\right.\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    from astropy.modeling.models import Ellipse2D\n    from astropy.coordinates import Angle\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as mpatches\n    x0, y0 = 25, 25\n    a, b = 20, 10\n    theta = Angle(30, 'deg')\n    e = Ellipse2D(amplitude=100., x_0=x0, y_0=y0, a=a, b=b,\n                  theta=theta.radian)\n    y, x = np.mgrid[0:50, 0:50]\n    fig, ax = plt.subplots(1, 1)\n    ax.imshow(e(x, y), origin='lower', interpolation='none', cmap='Greys_r')\n    e2 = mpatches.Ellipse((x0, y0), 2*a, 2*b, theta.degree, edgecolor='red',\n                          facecolor='none')\n    ax.add_patch(e2)\n    plt.show()",
                    "methods": [
                      "evaluate(x, y, amplitude, x_0, y_0, a, b, theta)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Disk2D(Fittable2DModel)",
                    "docstring": "Two dimensional radial symmetric Disk model.\n\nParameters\n----------\namplitude : float\n    Value of the disk function\nx_0 : float\n    x position center of the disk\ny_0 : float\n    y position center of the disk\nR_0 : float\n    Radius of the disk\n\nSee Also\n--------\nBox2D, TrapezoidDisk2D\n\nNotes\n-----\nModel formula:\n\n    .. math::\n\n        f(r) = \\left \\{\n                 \\begin{array}{ll}\n                   A & : r \\leq R_0 \\\\\n                   0 & : r > R_0\n                 \\end{array}\n               \\right.",
                    "methods": [
                      "evaluate(x, y, amplitude, x_0, y_0, R_0)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Ring2D(Fittable2DModel)",
                    "docstring": "Two dimensional radial symmetric Ring model.\n\nParameters\n----------\namplitude : float\n    Value of the disk function\nx_0 : float\n    x position center of the disk\ny_0 : float\n    y position center of the disk\nr_in : float\n    Inner radius of the ring\nwidth : float\n    Width of the ring.\nr_out : float\n    Outer Radius of the ring. Can be specified instead of width.\n\nSee Also\n--------\nDisk2D, TrapezoidDisk2D\n\nNotes\n-----\nModel formula:\n\n    .. math::\n\n        f(r) = \\left \\{\n                 \\begin{array}{ll}\n                   A & : r_{in} \\leq r \\leq r_{out} \\\\\n                   0 & : \\text{else}\n                 \\end{array}\n               \\right.\n\nWhere :math:`r_{out} = r_{in} + r_{width}`.",
                    "methods": [
                      "__init__(self, amplitude, x_0, y_0, r_in, width, r_out)",
                      "evaluate(x, y, amplitude, x_0, y_0, r_in, width)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Box1D(Fittable1DModel)",
                    "docstring": "One dimensional Box model.\n\nParameters\n----------\namplitude : float\n    Amplitude A\nx_0 : float\n    Position of the center of the box function\nwidth : float\n    Width of the box\n\nSee Also\n--------\nBox2D, TrapezoidDisk2D\n\nNotes\n-----\nModel formula:\n\n  .. math::\n\n        f(x) = \\left \\{\n                 \\begin{array}{ll}\n                   A & : x_0 - w/2 \\leq x \\leq x_0 + w/2 \\\\\n                   0 & : \\text{else}\n                 \\end{array}\n               \\right.\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Box1D\n\n    plt.figure()\n    s1 = Box1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        s1.width = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -1, 4])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, x_0, width)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "return_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Box2D(Fittable2DModel)",
                    "docstring": "Two dimensional Box model.\n\nParameters\n----------\namplitude : float\n    Amplitude\nx_0 : float\n    x position of the center of the box function\nx_width : float\n    Width in x direction of the box\ny_0 : float\n    y position of the center of the box function\ny_width : float\n    Width in y direction of the box\n\nSee Also\n--------\nBox1D, Gaussian2D, Moffat2D\n\nNotes\n-----\nModel formula:\n\n  .. math::\n\n        f(x, y) = \\left \\{\n                 \\begin{array}{ll}\n        A : & x_0 - w_x/2 \\leq x \\leq x_0 + w_x/2 \\text{ and} \\\\\n            & y_0 - w_y/2 \\leq y \\leq y_0 + w_y/2 \\\\\n        0 : & \\text{else}\n                 \\end{array}\n               \\right.",
                    "methods": [
                      "evaluate(x, y, amplitude, x_0, y_0, x_width, y_width)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Trapezoid1D(Fittable1DModel)",
                    "docstring": "One dimensional Trapezoid model.\n\nParameters\n----------\namplitude : float\n    Amplitude of the trapezoid\nx_0 : float\n    Center position of the trapezoid\nwidth : float\n    Width of the constant part of the trapezoid.\nslope : float\n    Slope of the tails of the trapezoid\n\nSee Also\n--------\nBox1D, Gaussian1D, Moffat1D\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Trapezoid1D\n\n    plt.figure()\n    s1 = Trapezoid1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        s1.width = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -1, 4])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, x_0, width, slope)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "TrapezoidDisk2D(Fittable2DModel)",
                    "docstring": "Two dimensional circular Trapezoid model.\n\nParameters\n----------\namplitude : float\n    Amplitude of the trapezoid\nx_0 : float\n    x position of the center of the trapezoid\ny_0 : float\n    y position of the center of the trapezoid\nR_0 : float\n    Radius of the constant part of the trapezoid.\nslope : float\n    Slope of the tails of the trapezoid in x direction.\n\nSee Also\n--------\nDisk2D, Box2D",
                    "methods": [
                      "evaluate(x, y, amplitude, x_0, y_0, R_0, slope)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "RickerWavelet1D(Fittable1DModel)",
                    "docstring": "One dimensional Ricker Wavelet model (sometimes known as a \"Mexican Hat\"\nmodel).\n\n.. note::\n\n    See https://github.com/astropy/astropy/pull/9445 for discussions\n    related to renaming of this model.\n\nParameters\n----------\namplitude : float\n    Amplitude\nx_0 : float\n    Position of the peak\nsigma : float\n    Width of the Ricker wavelet\n\nSee Also\n--------\nRickerWavelet2D, Box1D, Gaussian1D, Trapezoid1D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    f(x) = {A \\left(1 - \\frac{\\left(x - x_{0}\\right)^{2}}{\\sigma^{2}}\\right)\n    e^{- \\frac{\\left(x - x_{0}\\right)^{2}}{2 \\sigma^{2}}}}\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import RickerWavelet1D\n\n    plt.figure()\n    s1 = RickerWavelet1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        s1.width = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -2, 4])\n    plt.show()",
                    "methods": [
                      "evaluate(x, amplitude, x_0, sigma)",
                      "bounding_box(self, factor)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "RickerWavelet2D(Fittable2DModel)",
                    "docstring": "Two dimensional Ricker Wavelet model (sometimes known as a \"Mexican Hat\"\nmodel).\n\n.. note::\n\n    See https://github.com/astropy/astropy/pull/9445 for discussions\n    related to renaming of this model.\n\nParameters\n----------\namplitude : float\n    Amplitude\nx_0 : float\n    x position of the peak\ny_0 : float\n    y position of the peak\nsigma : float\n    Width of the Ricker wavelet\n\nSee Also\n--------\nRickerWavelet1D, Gaussian2D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    f(x, y) = A \\left(1 - \\frac{\\left(x - x_{0}\\right)^{2}\n    + \\left(y - y_{0}\\right)^{2}}{\\sigma^{2}}\\right)\n    e^{\\frac{- \\left(x - x_{0}\\right)^{2}\n    - \\left(y - y_{0}\\right)^{2}}{2 \\sigma^{2}}}",
                    "methods": [
                      "evaluate(x, y, amplitude, x_0, y_0, sigma)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "AiryDisk2D(Fittable2DModel)",
                    "docstring": "Two dimensional Airy disk model.\n\nParameters\n----------\namplitude : float\n    Amplitude of the Airy function.\nx_0 : float\n    x position of the maximum of the Airy function.\ny_0 : float\n    y position of the maximum of the Airy function.\nradius : float\n    The radius of the Airy disk (radius of the first zero).\n\nSee Also\n--------\nBox2D, TrapezoidDisk2D, Gaussian2D\n\nNotes\n-----\nModel formula:\n\n    .. math:: f(r) = A \\left[\\frac{2 J_1(\\frac{\\pi r}{R/R_z})}{\\frac{\\pi r}{R/R_z}}\\right]^2\n\nWhere :math:`J_1` is the first order Bessel function of the first\nkind, :math:`r` is radial distance from the maximum of the Airy\nfunction (:math:`r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}`), :math:`R`\nis the input ``radius`` parameter, and :math:`R_z =\n1.2196698912665045`).\n\nFor an optical system, the radius of the first zero represents the\nlimiting angular resolution and is approximately 1.22 * lambda / D,\nwhere lambda is the wavelength of the light and D is the diameter of\nthe aperture.\n\nSee [1]_ for more details about the Airy disk.\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Airy_disk",
                    "methods": [
                      "evaluate(cls, x, y, amplitude, x_0, y_0, radius)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Moffat1D(Fittable1DModel)",
                    "docstring": "One dimensional Moffat model.\n\nParameters\n----------\namplitude : float\n    Amplitude of the model.\nx_0 : float\n    x position of the maximum of the Moffat model.\ngamma : float\n    Core width of the Moffat model.\nalpha : float\n    Power index of the Moffat model.\n\nSee Also\n--------\nGaussian1D, Box1D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    f(x) = A \\left(1 + \\frac{\\left(x - x_{0}\\right)^{2}}{\\gamma^{2}}\\right)^{- \\alpha}\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    from astropy.modeling.models import Moffat1D\n\n    plt.figure()\n    s1 = Moffat1D()\n    r = np.arange(-5, 5, .01)\n\n    for factor in range(1, 4):\n        s1.amplitude = factor\n        s1.width = factor\n        plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)\n\n    plt.axis([-5, 5, -1, 4])\n    plt.show()",
                    "methods": [
                      "fwhm(self)",
                      "evaluate(x, amplitude, x_0, gamma, alpha)",
                      "fit_deriv(x, amplitude, x_0, gamma, alpha)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Moffat2D(Fittable2DModel)",
                    "docstring": "Two dimensional Moffat model.\n\nParameters\n----------\namplitude : float\n    Amplitude of the model.\nx_0 : float\n    x position of the maximum of the Moffat model.\ny_0 : float\n    y position of the maximum of the Moffat model.\ngamma : float\n    Core width of the Moffat model.\nalpha : float\n    Power index of the Moffat model.\n\nSee Also\n--------\nGaussian2D, Box2D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    f(x, y) = A \\left(1 + \\frac{\\left(x - x_{0}\\right)^{2} +\n    \\left(y - y_{0}\\right)^{2}}{\\gamma^{2}}\\right)^{- \\alpha}",
                    "methods": [
                      "fwhm(self)",
                      "evaluate(x, y, amplitude, x_0, y_0, gamma, alpha)",
                      "fit_deriv(x, y, amplitude, x_0, y_0, gamma, alpha)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Sersic2D(Fittable2DModel)",
                    "docstring": "Two dimensional Sersic surface brightness profile.\n\nParameters\n----------\namplitude : float\n    Surface brightness at r_eff.\nr_eff : float\n    Effective (half-light) radius\nn : float\n    Sersic Index.\nx_0 : float, optional\n    x position of the center.\ny_0 : float, optional\n    y position of the center.\nellip : float, optional\n    Ellipticity.\ntheta : float, optional\n    Rotation angle in radians, counterclockwise from\n    the positive x-axis.\n\nSee Also\n--------\nGaussian2D, Moffat2D\n\nNotes\n-----\nModel formula:\n\n.. math::\n\n    I(x,y) = I(r) = I_e\\exp\\left\\{-b_n\\left[\\left(\\frac{r}{r_{e}}\\right)^{(1/n)}-1\\right]\\right\\}\n\nThe constant :math:`b_n` is defined such that :math:`r_e` contains half the total\nluminosity, and can be solved for numerically.\n\n.. math::\n\n    \\Gamma(2n) = 2\\gamma (2n,b_n)\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    from astropy.modeling.models import Sersic2D\n    import matplotlib.pyplot as plt\n\n    x,y = np.meshgrid(np.arange(100), np.arange(100))\n\n    mod = Sersic2D(amplitude = 1, r_eff = 25, n=4, x_0=50, y_0=50,\n                   ellip=.5, theta=-1)\n    img = mod(x, y)\n    log_img = np.log10(img)\n\n\n    plt.figure()\n    plt.imshow(log_img, origin='lower', interpolation='nearest',\n               vmin=-1, vmax=2)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    cbar = plt.colorbar()\n    cbar.set_label('Log Brightness', rotation=270, labelpad=25)\n    cbar.set_ticks([-1, 0, 1, 2], update_ticks=True)\n    plt.show()\n\nReferences\n----------\n.. [1] http://ned.ipac.caltech.edu/level5/March05/Graham/Graham2.html",
                    "methods": [
                      "evaluate(cls, x, y, amplitude, r_eff, n, x_0, y_0, ellip, theta)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "KingProjectedAnalytic1D(Fittable1DModel)",
                    "docstring": "Projected (surface density) analytic King Model.\n\n\nParameters\n----------\namplitude : float\n    Amplitude or scaling factor.\nr_core : float\n    Core radius (f(r_c) ~ 0.5 f_0)\nr_tide : float\n    Tidal radius.\n\n\nNotes\n-----\n\nThis model approximates a King model with an analytic function. The derivation of this\nequation can be found in King '62 (equation 14). This is just an approximation of the\nfull model and the parameters derived from this model should be taken with caution.\nIt usually works for models with a concentration (c = log10(r_t/r_c) parameter < 2.\n\nModel formula:\n\n.. math::\n\n    f(x) = A r_c^2  \\left(\\frac{1}{\\sqrt{(x^2 + r_c^2)}} -\n    \\frac{1}{\\sqrt{(r_t^2 + r_c^2)}}\\right)^2\n\nExamples\n--------\n.. plot::\n    :include-source:\n\n    import numpy as np\n    from astropy.modeling.models import KingProjectedAnalytic1D\n    import matplotlib.pyplot as plt\n\n    plt.figure()\n    rt_list = [1, 2, 5, 10, 20]\n    for rt in rt_list:\n        r = np.linspace(0.1, rt, 100)\n\n        mod = KingProjectedAnalytic1D(amplitude = 1, r_core = 1., r_tide = rt)\n        sig = mod(r)\n\n\n        plt.loglog(r, sig/sig[0], label='c ~ {:0.2f}'.format(mod.concentration))\n\n    plt.xlabel(\"r\")\n    plt.ylabel(r\"$\\sigma/\\sigma_0$\")\n    plt.legend()\n    plt.show()\n\nReferences\n----------\n.. [1] https://ui.adsabs.harvard.edu/abs/1962AJ.....67..471K",
                    "methods": [
                      "concentration(self)",
                      "evaluate(x, amplitude, r_core, r_tide)",
                      "fit_deriv(x, amplitude, r_core, r_tide)",
                      "bounding_box(self)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Logarithmic1D(Fittable1DModel)",
                    "docstring": "One dimensional logarithmic model.\n\nParameters\n----------\namplitude : float, optional\ntau : float, optional\n\nSee Also\n--------\nExponential1D, Gaussian1D",
                    "methods": [
                      "evaluate(x, amplitude, tau)",
                      "fit_deriv(x, amplitude, tau)",
                      "inverse(self)",
                      "tau(self, val)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  },
                  {
                    "name": "Exponential1D(Fittable1DModel)",
                    "docstring": "One dimensional exponential model.\n\nParameters\n----------\namplitude : float, optional\ntau : float, optional\n\nSee Also\n--------\nLogarithmic1D, Gaussian1D",
                    "methods": [
                      "evaluate(x, amplitude, tau)",
                      "fit_deriv(x, amplitude, tau)",
                      "inverse(self)",
                      "tau(self, val)",
                      "input_units(self)",
                      "_parameter_units_for_data_units(self, inputs_unit, outputs_unit)"
                    ]
                  }
                ],
                "functions": []
              },
              {
                "file_path": "astropy/table/table.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "TableReplaceWarning(UserWarning)",
                    "docstring": "Warning class for cases when a table column is replaced via the\nTable.__setitem__ syntax e.g. t['a'] = val.\n\nThis does not inherit from AstropyWarning because we want to use\nstacklevel=3 to show the user where the issue occurred in their code.",
                    "methods": []
                  },
                  {
                    "name": "TableColumns(OrderedDict)",
                    "docstring": "OrderedDict subclass for a set of columns.\n\nThis class enhances item access to provide convenient access to columns\nby name or index, including slice access.  It also handles renaming\nof columns.\n\nThe initialization argument ``cols`` can be a list of ``Column`` objects\nor any structure that is valid for initializing a Python dict.  This\nincludes a dict, list of (key, val) tuples or [key, val] lists, etc.\n\nParameters\n----------\ncols : dict, list, tuple; optional\n    Column objects as data structure that can init dict (see above)",
                    "methods": [
                      "__init__(self, cols)",
                      "__getitem__(self, item)",
                      "__setitem__(self, item, value, validated)",
                      "__repr__(self)",
                      "_rename_column(self, name, new_name)",
                      "__delitem__(self, name)",
                      "isinstance(self, cls)",
                      "not_isinstance(self, cls)"
                    ]
                  },
                  {
                    "name": "TableAttribute(MetaAttribute)",
                    "docstring": "Descriptor to define a custom attribute for a Table subclass.\n\nThe value of the ``TableAttribute`` will be stored in a dict named\n``__attributes__`` that is stored in the table ``meta``.  The attribute\ncan be accessed and set in the usual way, and it can be provided when\ncreating the object.\n\nDefining an attribute by this mechanism ensures that it will persist if\nthe table is sliced or serialized, for example as a pickle or ECSV file.\n\nSee the `~astropy.utils.metadata.MetaAttribute` documentation for additional\ndetails.\n\nParameters\n----------\ndefault : object\n    Default value for attribute\n\nExamples\n--------\n  >>> from astropy.table import Table, TableAttribute\n  >>> class MyTable(Table):\n  ...     identifier = TableAttribute(default=1)\n  >>> t = MyTable(identifier=10)\n  >>> t.identifier\n  10\n  >>> t.meta\n  OrderedDict([('__attributes__', {'identifier': 10})])",
                    "methods": []
                  },
                  {
                    "name": "PprintIncludeExclude(TableAttribute)",
                    "docstring": "Maintain tuple that controls table column visibility for print output.\n\nThis is a descriptor that inherits from MetaAttribute so that the attribute\nvalue is stored in the table meta['__attributes__'].\n\nThis gets used for the ``pprint_include_names`` and ``pprint_exclude_names`` Table\nattributes.",
                    "methods": [
                      "__get__(self, instance, owner_cls)",
                      "__set__(self, instance, names)",
                      "__call__(self)",
                      "__repr__(self)",
                      "_add_remove_setup(self, names)",
                      "add(self, names)",
                      "remove(self, names)",
                      "_remove(self, names, raise_exc)",
                      "_rename(self, name, new_name)",
                      "set(self, names)"
                    ]
                  },
                  {
                    "name": "Table()",
                    "docstring": "A class to represent tables of heterogeneous data.\n\n`~astropy.table.Table` provides a class for heterogeneous tabular data.\nA key enhancement provided by the `~astropy.table.Table` class over\ne.g. a `numpy` structured array is the ability to easily modify the\nstructure of the table by adding or removing columns, or adding new\nrows of data.  In addition table and column metadata are fully supported.\n\n`~astropy.table.Table` differs from `~astropy.nddata.NDData` by the\nassumption that the input data consists of columns of homogeneous data,\nwhere each column has a unique identifier and may contain additional\nmetadata such as the data unit, format, and description.\n\nSee also: https://docs.astropy.org/en/stable/table/\n\nParameters\n----------\ndata : numpy ndarray, dict, list, table-like object, optional\n    Data to initialize table.\nmasked : bool, optional\n    Specify whether the table is masked.\nnames : list, optional\n    Specify column names.\ndtype : list, optional\n    Specify column data types.\nmeta : dict, optional\n    Metadata associated with the table.\ncopy : bool, optional\n    Copy the input data. If the input is a Table the ``meta`` is always\n    copied regardless of the ``copy`` parameter.\n    Default is True.\nrows : numpy ndarray, list of list, optional\n    Row-oriented data for table instead of ``data`` argument.\ncopy_indices : bool, optional\n    Copy any indices in the input data. Default is True.\nunits : list, dict, optional\n    List or dict of units to apply to columns.\ndescriptions : list, dict, optional\n    List or dict of descriptions to apply to columns.\n**kwargs : dict, optional\n    Additional keyword args when converting table-like object.",
                    "methods": [
                      "as_array(self, keep_byteorder, names)",
                      "__init__(self, data, masked, names, dtype, meta, copy, rows, copy_indices, units, descriptions)",
                      "_set_column_attribute(self, attr, values)",
                      "__getstate__(self)",
                      "__setstate__(self, state)",
                      "mask(self)",
                      "mask(self, val)",
                      "_mask(self)",
                      "filled(self, fill_value)",
                      "indices(self)",
                      "loc(self)",
                      "loc_indices(self)",
                      "iloc(self)",
                      "add_index(self, colnames, engine, unique)",
                      "remove_indices(self, colname)",
                      "index_mode(self, mode)",
                      "__array__(self, dtype)",
                      "_check_names_dtype(self, names, dtype, n_cols)",
                      "_init_from_list_of_dicts(self, data, names, dtype, n_cols, copy)",
                      "_init_from_list(self, data, names, dtype, n_cols, copy)",
                      "_convert_data_to_col(self, data, copy, default_name, dtype, name)",
                      "_init_from_ndarray(self, data, names, dtype, n_cols, copy)",
                      "_init_from_dict(self, data, names, dtype, n_cols, copy)",
                      "_get_col_cls_for_table(self, col)",
                      "_convert_col_for_table(self, col)",
                      "_init_from_cols(self, cols)",
                      "_new_from_slice(self, slice_)",
                      "_make_table_from_cols(table, cols, verify, names)",
                      "_set_col_parent_table_and_mask(self, col)",
                      "itercols(self)",
                      "_base_repr_(self, html, descr_vals, max_width, tableid, show_dtype, max_lines, tableclass)",
                      "_repr_html_(self)",
                      "__repr__(self)",
                      "__str__(self)",
                      "__bytes__(self)",
                      "has_mixin_columns(self)",
                      "has_masked_columns(self)",
                      "has_masked_values(self)",
                      "_is_mixin_for_table(self, col)",
                      "pprint(self, max_lines, max_width, show_name, show_unit, show_dtype, align)",
                      "pprint_all(self, max_lines, max_width, show_name, show_unit, show_dtype, align)",
                      "_make_index_row_display_table(self, index_row_name)",
                      "show_in_notebook(self, tableid, css, display_length, table_class, show_row_index)",
                      "show_in_browser(self, max_lines, jsviewer, browser, jskwargs, tableid, table_class, css, show_row_index)",
                      "pformat(self, max_lines, max_width, show_name, show_unit, show_dtype, html, tableid, align, tableclass)",
                      "pformat_all(self, max_lines, max_width, show_name, show_unit, show_dtype, html, tableid, align, tableclass)",
                      "more(self, max_lines, max_width, show_name, show_unit, show_dtype)",
                      "__getitem__(self, item)",
                      "__setitem__(self, item, value)",
                      "__delitem__(self, item)",
                      "_ipython_key_completions_(self)",
                      "field(self, item)",
                      "masked(self)",
                      "masked(self, masked)",
                      "_set_masked(self, masked)",
                      "ColumnClass(self)",
                      "dtype(self)",
                      "colnames(self)",
                      "_is_list_or_tuple_of_str(names)",
                      "keys(self)",
                      "values(self)",
                      "items(self)",
                      "__len__(self)",
                      "index_column(self, name)",
                      "add_column(self, col, index, name, rename_duplicate, copy, default_name)",
                      "add_columns(self, cols, indexes, names, copy, rename_duplicate)",
                      "_replace_column_warnings(self, name, col)",
                      "replace_column(self, name, col, copy)",
                      "remove_row(self, index)",
                      "remove_rows(self, row_specifier)",
                      "iterrows(self)",
                      "_set_of_names_in_colnames(self, names)",
                      "remove_column(self, name)",
                      "remove_columns(self, names)",
                      "_convert_string_dtype(self, in_kind, out_kind, encode_decode_func)",
                      "convert_bytestring_to_unicode(self)",
                      "convert_unicode_to_bytestring(self)",
                      "keep_columns(self, names)",
                      "rename_column(self, name, new_name)",
                      "rename_columns(self, names, new_names)",
                      "_set_row(self, idx, colnames, vals)",
                      "add_row(self, vals, mask)",
                      "insert_row(self, index, vals, mask)",
                      "_replace_cols(self, columns)",
                      "update(self, other, copy)",
                      "argsort(self, keys, kind, reverse)",
                      "sort(self, keys)",
                      "reverse(self)",
                      "round(self, decimals)",
                      "copy(self, copy_data)",
                      "__deepcopy__(self, memo)",
                      "__copy__(self)",
                      "__lt__(self, other)",
                      "__gt__(self, other)",
                      "__le__(self, other)",
                      "__ge__(self, other)",
                      "__eq__(self, other)",
                      "__ne__(self, other)",
                      "_rows_equal(self, other)",
                      "values_equal(self, other)",
                      "groups(self)",
                      "group_by(self, keys)",
                      "to_pandas(self, index, use_nullable_int)",
                      "from_pandas(cls, dataframe, index, units)"
                    ]
                  },
                  {
                    "name": "QTable(Table)",
                    "docstring": "A class to represent tables of heterogeneous data.\n\n`~astropy.table.QTable` provides a class for heterogeneous tabular data\nwhich can be easily modified, for instance adding columns or new rows.\n\nThe `~astropy.table.QTable` class is identical to `~astropy.table.Table`\nexcept that columns with an associated ``unit`` attribute are converted to\n`~astropy.units.Quantity` objects.\n\nSee also:\n\n- https://docs.astropy.org/en/stable/table/\n- https://docs.astropy.org/en/stable/table/mixin_columns.html\n\nParameters\n----------\ndata : numpy ndarray, dict, list, table-like object, optional\n    Data to initialize table.\nmasked : bool, optional\n    Specify whether the table is masked.\nnames : list, optional\n    Specify column names.\ndtype : list, optional\n    Specify column data types.\nmeta : dict, optional\n    Metadata associated with the table.\ncopy : bool, optional\n    Copy the input data. Default is True.\nrows : numpy ndarray, list of list, optional\n    Row-oriented data for table instead of ``data`` argument.\ncopy_indices : bool, optional\n    Copy any indices in the input data. Default is True.\n**kwargs : dict, optional\n    Additional keyword args when converting table-like object.",
                    "methods": [
                      "_is_mixin_for_table(self, col)",
                      "_convert_col_for_table(self, col)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "descr(col)",
                    "content": "def descr(col):\n    \"\"\"Array-interface compliant full description of a column.\n\n    This returns a 3-tuple (name, type, shape) that can always be\n    used in a structured array dtype definition.\n    \"\"\"\n    col_dtype = 'O' if (col.info.dtype is None) else col.info.dtype\n    col_shape = col.shape[1:] if hasattr(col, 'shape') else ()\n    return (col.info.name, col_dtype, col_shape)"
                  },
                  {
                    "name": "has_info_class(obj, cls)",
                    "content": "def has_info_class(obj, cls):\n    \"\"\"Check if the object's info is an instance of cls.\"\"\"\n    # We check info on the class of the instance, since on the instance\n    # itself accessing 'info' has side effects in that it sets\n    # obj.__dict__['info'] if it does not exist already.\n    return isinstance(getattr(obj.__class__, 'info', None), cls)"
                  },
                  {
                    "name": "_get_names_from_list_of_dict(rows)",
                    "content": "def _get_names_from_list_of_dict(rows):\n    \"\"\"Return list of column names if ``rows`` is a list of dict that\n    defines table data.\n\n    If rows is not a list of dict then return None.\n...\n    for row in rows:\n        if not isinstance(row, Mapping):\n            return None\n        names.update(row)\n    return list(names)"
                  }
                ]
              },
              {
                "file_path": "astropy/wcs/utils.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "custom_wcs_to_frame_mappings()",
                    "docstring": null,
                    "methods": [
                      "__init__(self, mappings)",
                      "__enter__(self)",
                      "__exit__(self, type, value, tb)"
                    ]
                  },
                  {
                    "name": "custom_frame_to_wcs_mappings()",
                    "docstring": null,
                    "methods": [
                      "__init__(self, mappings)",
                      "__enter__(self)",
                      "__exit__(self, type, value, tb)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "add_stokes_axis_to_wcs(wcs, add_before_ind)",
                    "content": "def add_stokes_axis_to_wcs(wcs, add_before_ind):\n    \"\"\"\n    Add a new Stokes axis that is uncorrelated with any other axes.\n\n    Parameters\n...\n    inds.insert(add_before_ind, 0)\n    newwcs = wcs.sub(inds)\n    newwcs.wcs.ctype[add_before_ind] = 'STOKES'\n    newwcs.wcs.cname[add_before_ind] = 'STOKES'\n    return newwcs"
                  },
                  {
                    "name": "_wcs_to_celestial_frame_builtin(wcs)",
                    "content": "def _wcs_to_celestial_frame_builtin(wcs):\n\n    # Import astropy.coordinates here to avoid circular imports\n    from astropy.coordinates import (FK4, FK5, ICRS, ITRS, FK4NoETerms,\n                                     Galactic, SphericalRepresentation)\n...\n                         obstime=wcs.wcs.dateobs or None)\n        else:\n            frame = None\n\n    return frame"
                  },
                  {
                    "name": "_celestial_frame_to_wcs_builtin(frame, projection)",
                    "content": "def _celestial_frame_to_wcs_builtin(frame, projection='TAN'):\n\n    # Import astropy.coordinates here to avoid circular imports\n    from astropy.coordinates import FK4, FK5, ICRS, ITRS, BaseRADecFrame, FK4NoETerms, Galactic\n\n...\n        return None\n\n    wcs.wcs.ctype = [xcoord + '-' + projection, ycoord + '-' + projection]\n\n    return wcs"
                  },
                  {
                    "name": "wcs_to_celestial_frame(wcs)",
                    "content": "def wcs_to_celestial_frame(wcs):\n    \"\"\"\n    For a given WCS, return the coordinate frame that matches the celestial\n    component of the WCS.\n\n...\n            frame = func(wcs)\n            if frame is not None:\n                return frame\n    raise ValueError(\"Could not determine celestial frame corresponding to \"\n                     \"the specified WCS object\")"
                  },
                  {
                    "name": "celestial_frame_to_wcs(frame, projection)",
                    "content": "def celestial_frame_to_wcs(frame, projection='TAN'):\n    \"\"\"\n    For a given coordinate frame, return the corresponding WCS object.\n\n    Note that the returned WCS object has only the elements corresponding to\n...\n            wcs = func(frame, projection=projection)\n            if wcs is not None:\n                return wcs\n    raise ValueError(\"Could not determine WCS corresponding to the specified \"\n                     \"coordinate frame.\")"
                  },
                  {
                    "name": "proj_plane_pixel_scales(wcs)",
                    "content": "def proj_plane_pixel_scales(wcs):\n    \"\"\"\n    For a WCS returns pixel scales along each axis of the image pixel at\n    the ``CRPIX`` location once it is projected onto the\n    \"plane of intermediate world coordinates\" as defined in\n...\n    --------\n    astropy.wcs.utils.proj_plane_pixel_area\n\n    \"\"\"\n    return np.sqrt((wcs.pixel_scale_matrix**2).sum(axis=0, dtype=float))"
                  },
                  {
                    "name": "proj_plane_pixel_area(wcs)",
                    "content": "def proj_plane_pixel_area(wcs):\n    \"\"\"\n    For a **celestial** WCS (see `astropy.wcs.WCS.celestial`) returns pixel\n    area of the image pixel at the ``CRPIX`` location once it is projected\n    onto the \"plane of intermediate world coordinates\" as defined in\n...\n    \"\"\"\n    psm = wcs.celestial.pixel_scale_matrix\n    if psm.shape != (2, 2):\n        raise ValueError(\"Pixel area is defined only for 2D pixels.\")\n    return np.abs(np.linalg.det(psm))"
                  },
                  {
                    "name": "is_proj_plane_distorted(wcs, maxerr)",
                    "content": "def is_proj_plane_distorted(wcs, maxerr=1.0e-5):\n    r\"\"\"\n    For a WCS returns `False` if square image (detector) pixels stay square\n    when projected onto the \"plane of intermediate world coordinates\"\n    as defined in\n...\n\n    \"\"\"\n    cwcs = wcs.celestial\n    return (not _is_cd_orthogonal(cwcs.pixel_scale_matrix, maxerr) or\n            _has_distortion(cwcs))"
                  },
                  {
                    "name": "_is_cd_orthogonal(cd, maxerr)",
                    "content": "def _is_cd_orthogonal(cd, maxerr):\n    shape = cd.shape\n    if not (len(shape) == 2 and shape[0] == shape[1]):\n        raise ValueError(\"CD (or PC) matrix must be a 2D square matrix.\")\n\n...\n    # However, I am not aware of complex CD/PC matrices...\n    I = np.dot(cd, cd.T) / pixarea\n    cd_unitary_err = np.amax(np.abs(I - np.eye(shape[0])))\n\n    return (cd_unitary_err < maxerr)"
                  },
                  {
                    "name": "non_celestial_pixel_scales(inwcs)",
                    "content": "def non_celestial_pixel_scales(inwcs):\n    \"\"\"\n    Calculate the pixel scale along each axis of a non-celestial WCS,\n    for example one with mixed spectral and spatial axes.\n\n...\n\n    if np.allclose(np.extract(1-np.eye(*pccd.shape), pccd), 0):\n        return np.abs(np.diagonal(pccd))*u.deg\n    else:\n        raise ValueError(\"WCS is rotated, cannot determine consistent pixel scales\")"
                  },
                  {
                    "name": "_has_distortion(wcs)",
                    "content": "def _has_distortion(wcs):\n    \"\"\"\n    `True` if contains any SIP or image distortion components.\n    \"\"\"\n    return any(getattr(wcs, dist_attr) is not None\n               for dist_attr in ['cpdis1', 'cpdis2', 'det2im1', 'det2im2', 'sip'])"
                  },
                  {
                    "name": "skycoord_to_pixel(coords, wcs, origin, mode)",
                    "content": "def skycoord_to_pixel(coords, wcs, origin=0, mode='all'):\n    \"\"\"\n    Convert a set of SkyCoord coordinates into pixels.\n\n    Parameters\n...\n        xp, yp = wcs.wcs_world2pix(lon.value, lat.value, origin)\n    else:\n        raise ValueError(\"mode should be either 'all' or 'wcs'\")\n\n    return xp, yp"
                  },
                  {
                    "name": "pixel_to_skycoord(xp, yp, wcs, origin, mode, cls)",
                    "content": "def pixel_to_skycoord(xp, yp, wcs, origin=0, mode='all', cls=None):\n    \"\"\"\n    Convert a set of pixel coordinates into a `~astropy.coordinates.SkyCoord`\n    coordinate.\n\n...\n    # Create a SkyCoord-like object\n    data = UnitSphericalRepresentation(lon=lon, lat=lat)\n    coords = cls(frame.realize_frame(data))\n\n    return coords"
                  },
                  {
                    "name": "_unique_with_order_preserved(items)",
                    "content": "def _unique_with_order_preserved(items):\n    \"\"\"\n    Return a list of unique items in the list provided, preserving the order\n    in which they are found.\n    \"\"\"\n...\n    new_items = []\n    for item in items:\n        if item not in new_items:\n            new_items.append(item)\n    return new_items"
                  },
                  {
                    "name": "_pixel_to_world_correlation_matrix(wcs)",
                    "content": "def _pixel_to_world_correlation_matrix(wcs):\n    \"\"\"\n    Return a correlation matrix between the pixel coordinates and the\n    high level world coordinates, along with the list of high level world\n    coordinate classes.\n...\n        matrix[iworld_unique] |= axis_correlation_matrix[iworld]\n\n    classes = [all_classes[component][0] for component in components]\n\n    return matrix, classes"
                  },
                  {
                    "name": "_pixel_to_pixel_correlation_matrix(wcs_in, wcs_out)",
                    "content": "def _pixel_to_pixel_correlation_matrix(wcs_in, wcs_out):\n    \"\"\"\n    Correlation matrix between the input and output pixel coordinates for a\n    pixel -> world -> pixel transformation specified by two WCS instances.\n\n...\n        raise ValueError(\"World coordinate order doesn't match and automatic matching is ambiguous\")\n\n    matrix = np.matmul(matrix2.T, matrix1)\n\n    return matrix"
                  },
                  {
                    "name": "_split_matrix(matrix)",
                    "content": "def _split_matrix(matrix):\n    \"\"\"\n    Given an axis correlation matrix from a WCS object, return information about\n    the individual WCS that can be split out.\n\n...\n        world_indices = list(np.nonzero(world_include)[0])\n        pixel_used.extend(pixel_indices)\n        split_info.append((pixel_indices, world_indices))\n\n    return split_info"
                  },
                  {
                    "name": "pixel_to_pixel(wcs_in, wcs_out)",
                    "content": "def pixel_to_pixel(wcs_in, wcs_out, *inputs):\n    \"\"\"\n    Transform pixel coordinates in a dataset with a WCS to pixel coordinates\n    in another dataset with a different WCS.\n\n...\n        for ipix in range(wcs_out.pixel_n_dim):\n            if ipix in pixel_out_indices:\n                outputs[ipix] = np.broadcast_to(pixel_outputs[ipix], original_shape)\n\n    return outputs[0] if wcs_out.pixel_n_dim == 1 else outputs"
                  },
                  {
                    "name": "local_partial_pixel_derivatives(wcs)",
                    "content": "def local_partial_pixel_derivatives(wcs, *pixel, normalize_by_world=False):\n    \"\"\"\n    Return a matrix of shape ``(world_n_dim, pixel_n_dim)`` where each entry\n    ``[i, j]`` is the partial derivative d(world_i)/d(pixel_j) at the requested\n    pixel position.\n...\n\n    if normalize_by_world:\n        derivatives /= derivatives.sum(axis=0)[:, np.newaxis]\n\n    return derivatives"
                  },
                  {
                    "name": "_linear_wcs_fit(params, lon, lat, x, y, w_obj)",
                    "content": "def _linear_wcs_fit(params, lon, lat, x, y, w_obj):\n    \"\"\"\n    Objective function for fitting linear terms.\n\n    Parameters\n...\n    lon_resids = np.mod(lon_resids - 180.0, 360.0) - 180.0\n\n    resids = np.concatenate((lon_resids * np.cos(np.radians(lat)), lat_resids))\n\n    return resids"
                  },
                  {
                    "name": "_sip_fit(params, lon, lat, u, v, w_obj, order, coeff_names)",
                    "content": "def _sip_fit(params, lon, lat, u, v, w_obj, order, coeff_names):\n\n    \"\"\" Objective function for fitting SIP.\n\n    Parameters\n...\n    x, y = np.dot(w_obj.wcs.cd, (x-w_obj.wcs.crpix[0], y-w_obj.wcs.crpix[1]))\n\n    resids = np.concatenate((x-xo, y-yo))\n\n    return resids"
                  },
                  {
                    "name": "fit_wcs_from_points(xy, world_coords, proj_point, projection, sip_degree)",
                    "content": "def fit_wcs_from_points(xy, world_coords, proj_point='center',\n                        projection='TAN', sip_degree=None):\n    \"\"\"\n    Given two matching sets of coordinates on detector and sky,\n    compute the WCS.\n...\n\n        wcs.sip = Sip(a_vals, b_vals, np.zeros((degree+1, degree+1)),\n                      np.zeros((degree+1, degree+1)), wcs.wcs.crpix)\n\n    return wcs"
                  },
                  {
                    "name": "obsgeo_to_frame(obsgeo, obstime)",
                    "content": "def obsgeo_to_frame(obsgeo, obstime):\n    \"\"\"\n    Convert a WCS obsgeo property into an `~.builtin_frames.ITRS` coordinate frame.\n\n    Parameters\n...\n    # Otherwise we assume the cartesian ones are valid\n    else:\n        data = CartesianRepresentation(*obsgeo[:3] * u.m)\n\n    return ITRS(data, obstime=obstime)"
                  }
                ]
              },
              {
                "file_path": "astropy/extern/configobj/configobj.py",
                "module_docstring": null,
                "classes": [
                  {
                    "name": "UnknownType(Exception)",
                    "docstring": null,
                    "methods": []
                  },
                  {
                    "name": "Builder(object)",
                    "docstring": null,
                    "methods": [
                      "build(self, o)",
                      "build_List(self, o)",
                      "build_Const(self, o)",
                      "build_Dict(self, o)",
                      "build_Tuple(self, o)",
                      "build_Name(self, o)",
                      "build_Add(self, o)",
                      "build_Getattr(self, o)",
                      "build_UnarySub(self, o)",
                      "build_UnaryAdd(self, o)"
                    ]
                  },
                  {
                    "name": "ConfigObjError(SyntaxError)",
                    "docstring": "This is the base class for all errors that ConfigObj raises.\nIt is a subclass of SyntaxError.",
                    "methods": [
                      "__init__(self, message, line_number, line)"
                    ]
                  },
                  {
                    "name": "NestingError(ConfigObjError)",
                    "docstring": "This error indicates a level of nesting that doesn't match.",
                    "methods": []
                  },
                  {
                    "name": "ParseError(ConfigObjError)",
                    "docstring": "This error indicates that a line is badly written.\nIt is neither a valid ``key = value`` line,\nnor a valid section marker line.",
                    "methods": []
                  },
                  {
                    "name": "ReloadError(IOError)",
                    "docstring": "A 'reload' operation failed.\nThis exception is a subclass of ``IOError``.",
                    "methods": [
                      "__init__(self)"
                    ]
                  },
                  {
                    "name": "DuplicateError(ConfigObjError)",
                    "docstring": "The keyword or section specified already exists.",
                    "methods": []
                  },
                  {
                    "name": "ConfigspecError(ConfigObjError)",
                    "docstring": "An error occured whilst parsing a configspec.",
                    "methods": []
                  },
                  {
                    "name": "InterpolationError(ConfigObjError)",
                    "docstring": "Base class for the two interpolation errors.",
                    "methods": []
                  },
                  {
                    "name": "InterpolationLoopError(InterpolationError)",
                    "docstring": "Maximum interpolation depth exceeded in string interpolation.",
                    "methods": [
                      "__init__(self, option)"
                    ]
                  },
                  {
                    "name": "RepeatSectionError(ConfigObjError)",
                    "docstring": "This error indicates additional sections in a section with a\n``__many__`` (repeated) section.",
                    "methods": []
                  },
                  {
                    "name": "MissingInterpolationOption(InterpolationError)",
                    "docstring": "A value specified for interpolation was missing.",
                    "methods": [
                      "__init__(self, option)"
                    ]
                  },
                  {
                    "name": "UnreprError(ConfigObjError)",
                    "docstring": "An error parsing in unrepr mode.",
                    "methods": []
                  },
                  {
                    "name": "InterpolationEngine(object)",
                    "docstring": "A helper class to help perform string interpolation.\n\nThis class is an abstract base class; its descendants perform\nthe actual work.",
                    "methods": [
                      "__init__(self, section)",
                      "interpolate(self, key, value)",
                      "_fetch(self, key)",
                      "_parse_match(self, match)"
                    ]
                  },
                  {
                    "name": "ConfigParserInterpolation(InterpolationEngine)",
                    "docstring": "Behaves like ConfigParser.",
                    "methods": [
                      "_parse_match(self, match)"
                    ]
                  },
                  {
                    "name": "TemplateInterpolation(InterpolationEngine)",
                    "docstring": "Behaves like string.Template.",
                    "methods": [
                      "_parse_match(self, match)"
                    ]
                  },
                  {
                    "name": "Section(dict)",
                    "docstring": "A dictionary-like object that represents a section in a config file.\n\nIt does string interpolation if the 'interpolation' attribute\nof the 'main' object is set to True.\n\nInterpolation is tried first from this object, then from the 'DEFAULT'\nsection of this object, next from the parent and its 'DEFAULT' section,\nand so on until the main object is reached.\n\nA Section will behave like an ordered dictionary - following the\norder of the ``scalars`` and ``sections`` attributes.\nYou can use this to change the order of members.\n\nIteration follows the order: scalars, then sections.",
                    "methods": [
                      "__setstate__(self, state)",
                      "__reduce__(self)",
                      "__init__(self, parent, depth, main, indict, name)",
                      "_initialise(self)",
                      "_interpolate(self, key, value)",
                      "__getitem__(self, key)",
                      "__setitem__(self, key, value, unrepr)",
                      "__delitem__(self, key)",
                      "get(self, key, default)",
                      "update(self, indict)",
                      "pop(self, key, default)",
                      "popitem(self)",
                      "clear(self)",
                      "setdefault(self, key, default)",
                      "items(self)",
                      "keys(self)",
                      "values(self)",
                      "iteritems(self)",
                      "iterkeys(self)",
                      "itervalues(self)",
                      "__repr__(self)",
                      "dict(self)",
                      "merge(self, indict)",
                      "rename(self, oldkey, newkey)",
                      "walk(self, function, raise_errors, call_on_sections)",
                      "as_bool(self, key)",
                      "as_int(self, key)",
                      "as_float(self, key)",
                      "as_list(self, key)",
                      "restore_default(self, key)",
                      "restore_defaults(self)"
                    ]
                  },
                  {
                    "name": "ConfigObj(Section)",
                    "docstring": "An object to read, create, and write config files.",
                    "methods": [
                      "__init__(self, infile, options, configspec, encoding, interpolation, raise_errors, list_values, create_empty, file_error, stringify, indent_type, default_encoding, unrepr, write_empty_values, _inspec)",
                      "_load(self, infile, configspec)",
                      "_initialise(self, options)",
                      "__repr__(self)",
                      "_handle_bom(self, infile)",
                      "_a_to_u(self, aString)",
                      "_decode(self, infile, encoding)",
                      "_decode_element(self, line)",
                      "_str(self, value)",
                      "_parse(self, infile)",
                      "_match_depth(self, sect, depth)",
                      "_handle_error(self, text, ErrorClass, infile, cur_index)",
                      "_unquote(self, value)",
                      "_quote(self, value, multiline)",
                      "_get_single_quote(self, value)",
                      "_get_triple_quote(self, value)",
                      "_handle_value(self, value)",
                      "_multiline(self, value, infile, cur_index, maxline)",
                      "_handle_configspec(self, configspec)",
                      "_set_configspec(self, section, copy)",
                      "_write_line(self, indent_string, entry, this_entry, comment)",
                      "_write_marker(self, indent_string, depth, entry, comment)",
                      "_handle_comment(self, comment)",
                      "write(self, outfile, section)",
                      "validate(self, validator, preserve_errors, copy, section)",
                      "reset(self)",
                      "reload(self)"
                    ]
                  },
                  {
                    "name": "SimpleVal(object)",
                    "docstring": "A simple validator.\nCan be used to check that all members expected are present.\n\nTo use it, provide a configspec with all your members in (the value given\nwill be ignored). Pass an instance of ``SimpleVal`` to the ``validate``\nmethod of your ``ConfigObj``. ``validate`` will return ``True`` if all\nmembers are present, or a dictionary with True/False meaning\npresent/missing. (Whole missing sections will be replaced with ``False``)",
                    "methods": [
                      "__init__(self)",
                      "check(self, check, member, missing)"
                    ]
                  }
                ],
                "functions": [
                  {
                    "name": "match_utf8(encoding)",
                    "content": "def match_utf8(encoding):\n    return BOM_LIST.get(encoding.lower()) == 'utf_8'"
                  },
                  {
                    "name": "getObj(s)",
                    "content": "def getObj(s):\n    global compiler\n    if compiler is None:\n        import compiler\n    s = \"a=\" + s\n    p = compiler.parse(s)\n    return p.getChildren()[1].getChildren()[0].getChildren()[1]"
                  },
                  {
                    "name": "unrepr(s)",
                    "content": "def unrepr(s):\n    if not s:\n        return s\n\n    # this is supposed to be safe\n    import ast\n    return ast.literal_eval(s)"
                  },
                  {
                    "name": "__newobj__(cls)",
                    "content": "def __newobj__(cls, *args):\n    # Hack for pickle\n    return cls.__new__(cls, *args)"
                  },
                  {
                    "name": "flatten_errors(cfg, res, levels, results)",
                    "content": "def flatten_errors(cfg, res, levels=None, results=None):\n    \"\"\"\n    An example function that will turn a nested dictionary of results\n    (as returned by ``ConfigObj.validate``) into a flat list.\n\n...\n    # Go up one level\n    if levels:\n        levels.pop()\n    #\n    return sorted(results)"
                  },
                  {
                    "name": "get_extra_values(conf, _prepend)",
                    "content": "def get_extra_values(conf, _prepend=()):\n    \"\"\"\n    Find all the values and sections not in the configspec from a validated\n    ConfigObj.\n\n...\n    out.extend([(_prepend, name) for name in conf.extra_values])\n    for name in conf.sections:\n        if name not in conf.extra_values:\n            out.extend(get_extra_values(conf[name], _prepend + (name,)))\n    return out"
                  }
                ]
              }
            ],
            "task": "In this task, you will be provided with a software development issue from a real-world GitHub repository, along with the repository's README file and a set of preliminarily retrieved files (documentation). Your objective is to carefully analyze the issue in the context of the provided files and identify the most relevant files that are likely candidates for modification to resolve the issue."
          },
          "output control": {
            "files for editing": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "role": "assistant",
        "content": {
          "files for editing": [
            "astropy/modeling/separable.py"
          ]
        }
      }
    ],
    "instance_id": "astropy__astropy-12907"
  }
]